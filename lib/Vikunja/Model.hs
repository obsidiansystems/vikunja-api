{-
   Vikunja API

   # Pagination Every endpoint capable of pagination will return two headers: * `x-pagination-total-pages`: The total number of available pages for this request * `x-pagination-result-count`: The number of items returned for this request. # Rights All endpoints which return a single item (project, task, etc.) - no array - will also return a `x-max-right` header with the max right the user has on this item as an int where `0` is `Read Only`, `1` is `Read & Write` and `2` is `Admin`. This can be used to show or hide ui elements based on the rights the user has. # Errors All errors have an error code and a human-readable error message in addition to the http status code. You should always check for the status code in the response, not only the http status code. Due to limitations in the swagger library we're using for this document, only one error per http status code is documented here. Make sure to check the [error docs](https://vikunja.io/docs/errors/) in Vikunja's documentation for a full list of available error codes. # Authorization **JWT-Auth:** Main authorization method, used for most of the requests. Needs `Authorization: Bearer <jwt-token>`-header to authenticate successfully.  **API Token:** You can create scoped API tokens for your user and use the token to make authenticated requests in the context of that user. The token must be provided via an `Authorization: Bearer <token>` header, similar to jwt auth. See the documentation for the `api` group to manage token creation and revocation.  **BasicAuth:** Only used when requesting tasks via CalDAV. <!-- ReDoc-Inject: <security-definitions> -->

   OpenAPI Version: 3.0.1
   Vikunja API API version: 0.24.6
   Contact: hello@vikunja.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Vikunja.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Vikunja.Model where

import Vikunja.Core
import Vikunja.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AttachmentId
newtype AttachmentId = AttachmentId { unAttachmentId :: Int } deriving (P.Eq, P.Show)

-- ** Avatar
newtype Avatar = Avatar { unAvatar :: Text } deriving (P.Eq, P.Show)

-- ** Background
newtype Background = Background { unBackground :: Text } deriving (P.Eq, P.Show)

-- ** Bucket
newtype Bucket = Bucket { unBucket :: Int } deriving (P.Eq, P.Show)

-- ** BucketId
newtype BucketId = BucketId { unBucketId :: Int } deriving (P.Eq, P.Show)

-- ** CommentId
newtype CommentId = CommentId { unCommentId :: Int } deriving (P.Eq, P.Show)

-- ** Entity
newtype Entity = Entity { unEntity :: Text } deriving (P.Eq, P.Show)

-- ** EntityId
newtype EntityId = EntityId { unEntityId :: Text } deriving (P.Eq, P.Show)

-- ** Expand
newtype Expand = Expand { unExpand :: Text } deriving (P.Eq, P.Show)

-- ** Files
newtype Files = Files { unFiles :: Text } deriving (P.Eq, P.Show)

-- ** Filter
newtype Filter = Filter { unFilter :: Text } deriving (P.Eq, P.Show)

-- ** FilterIncludeNulls
newtype FilterIncludeNulls = FilterIncludeNulls { unFilterIncludeNulls :: Text } deriving (P.Eq, P.Show)

-- ** FilterTimezone
newtype FilterTimezone = FilterTimezone { unFilterTimezone :: Text } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Int } deriving (P.Eq, P.Show)

-- ** Image
newtype Image = Image { unImage :: Int } deriving (P.Eq, P.Show)

-- ** IsArchived
newtype IsArchived = IsArchived { unIsArchived :: Bool } deriving (P.Eq, P.Show)

-- ** Kind
newtype Kind = Kind { unKind :: Int } deriving (P.Eq, P.Show)

-- ** Label
newtype Label = Label { unLabel :: Int } deriving (P.Eq, P.Show)

-- ** OrderBy
newtype OrderBy = OrderBy { unOrderBy :: Text } deriving (P.Eq, P.Show)

-- ** OtherTaskId
newtype OtherTaskId = OtherTaskId { unOtherTaskId :: Int } deriving (P.Eq, P.Show)

-- ** P
newtype P = P { unP :: Int } deriving (P.Eq, P.Show)

-- ** Page
newtype Page = Page { unPage :: Int } deriving (P.Eq, P.Show)

-- ** ParamImport
newtype ParamImport = ParamImport { unParamImport :: Text } deriving (P.Eq, P.Show)

-- ** PerPage
newtype PerPage = PerPage { unPerPage :: Int } deriving (P.Eq, P.Show)

-- ** PreviewSize
newtype PreviewSize = PreviewSize { unPreviewSize :: Text } deriving (P.Eq, P.Show)

-- ** Project
newtype Project = Project { unProject :: Int } deriving (P.Eq, P.Show)

-- ** ProjectId
newtype ProjectId = ProjectId { unProjectId :: Int } deriving (P.Eq, P.Show)

-- ** Provider
newtype Provider = Provider { unProvider :: Int } deriving (P.Eq, P.Show)

-- ** RelationKind
newtype RelationKind = RelationKind { unRelationKind :: Text } deriving (P.Eq, P.Show)

-- ** S
newtype S = S { unS :: Text } deriving (P.Eq, P.Show)

-- ** Share
newtype Share = Share { unShare :: Int } deriving (P.Eq, P.Show)

-- ** ShareText
newtype ShareText = ShareText { unShareText :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Int } deriving (P.Eq, P.Show)

-- ** SortBy
newtype SortBy = SortBy { unSortBy :: Text } deriving (P.Eq, P.Show)

-- ** Table
newtype Table = Table { unTable :: Text } deriving (P.Eq, P.Show)

-- ** Task
newtype Task = Task { unTask :: Int } deriving (P.Eq, P.Show)

-- ** TaskId
newtype TaskId = TaskId { unTaskId :: Int } deriving (P.Eq, P.Show)

-- ** TeamId
newtype TeamId = TeamId { unTeamId :: Int } deriving (P.Eq, P.Show)

-- ** TokenId
newtype TokenId = TokenId { unTokenId :: Int } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Int } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- ** View
newtype View = View { unView :: Int } deriving (P.Eq, P.Show)

-- ** WebhookId
newtype WebhookId = WebhookId { unWebhookId :: Int } deriving (P.Eq, P.Show)

-- * Models


-- ** AuthToken
-- | AuthToken
data AuthToken = AuthToken
  { authTokenToken :: !(Maybe Text) -- ^ "token"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthToken
instance A.FromJSON AuthToken where
  parseJSON = A.withObject "AuthToken" $ \o ->
    AuthToken
      <$> (o .:? "token")

-- | ToJSON AuthToken
instance A.ToJSON AuthToken where
  toJSON AuthToken {..} =
   _omitNulls
      [ "token" .= authTokenToken
      ]


-- | Construct a value of type 'AuthToken' (by applying it's required fields, if any)
mkAuthToken
  :: AuthToken
mkAuthToken =
  AuthToken
  { authTokenToken = Nothing
  }

-- ** BackgroundImage
-- | BackgroundImage
data BackgroundImage = BackgroundImage
  { backgroundImageBlurHash :: !(Maybe Text) -- ^ "blur_hash"
  , backgroundImageId :: !(Maybe Text) -- ^ "id"
  , backgroundImageInfo :: !(Maybe A.Value) -- ^ "info" - This can be used to supply extra information from an image provider to clients
  , backgroundImageThumb :: !(Maybe Text) -- ^ "thumb"
  , backgroundImageUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BackgroundImage
instance A.FromJSON BackgroundImage where
  parseJSON = A.withObject "BackgroundImage" $ \o ->
    BackgroundImage
      <$> (o .:? "blur_hash")
      <*> (o .:? "id")
      <*> (o .:? "info")
      <*> (o .:? "thumb")
      <*> (o .:? "url")

-- | ToJSON BackgroundImage
instance A.ToJSON BackgroundImage where
  toJSON BackgroundImage {..} =
   _omitNulls
      [ "blur_hash" .= backgroundImageBlurHash
      , "id" .= backgroundImageId
      , "info" .= backgroundImageInfo
      , "thumb" .= backgroundImageThumb
      , "url" .= backgroundImageUrl
      ]


-- | Construct a value of type 'BackgroundImage' (by applying it's required fields, if any)
mkBackgroundImage
  :: BackgroundImage
mkBackgroundImage =
  BackgroundImage
  { backgroundImageBlurHash = Nothing
  , backgroundImageId = Nothing
  , backgroundImageInfo = Nothing
  , backgroundImageThumb = Nothing
  , backgroundImageUrl = Nothing
  }

-- ** FilesFile
-- | FilesFile
data FilesFile = FilesFile
  { filesFileCreated :: !(Maybe Text) -- ^ "created"
  , filesFileId :: !(Maybe Int) -- ^ "id"
  , filesFileMime :: !(Maybe Text) -- ^ "mime"
  , filesFileName :: !(Maybe Text) -- ^ "name"
  , filesFileSize :: !(Maybe Int) -- ^ "size"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FilesFile
instance A.FromJSON FilesFile where
  parseJSON = A.withObject "FilesFile" $ \o ->
    FilesFile
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "mime")
      <*> (o .:? "name")
      <*> (o .:? "size")

-- | ToJSON FilesFile
instance A.ToJSON FilesFile where
  toJSON FilesFile {..} =
   _omitNulls
      [ "created" .= filesFileCreated
      , "id" .= filesFileId
      , "mime" .= filesFileMime
      , "name" .= filesFileName
      , "size" .= filesFileSize
      ]


-- | Construct a value of type 'FilesFile' (by applying it's required fields, if any)
mkFilesFile
  :: FilesFile
mkFilesFile =
  FilesFile
  { filesFileCreated = Nothing
  , filesFileId = Nothing
  , filesFileMime = Nothing
  , filesFileName = Nothing
  , filesFileSize = Nothing
  }

-- ** HandlerAuthURL
-- | HandlerAuthURL
data HandlerAuthURL = HandlerAuthURL
  { handlerAuthURLUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HandlerAuthURL
instance A.FromJSON HandlerAuthURL where
  parseJSON = A.withObject "HandlerAuthURL" $ \o ->
    HandlerAuthURL
      <$> (o .:? "url")

-- | ToJSON HandlerAuthURL
instance A.ToJSON HandlerAuthURL where
  toJSON HandlerAuthURL {..} =
   _omitNulls
      [ "url" .= handlerAuthURLUrl
      ]


-- | Construct a value of type 'HandlerAuthURL' (by applying it's required fields, if any)
mkHandlerAuthURL
  :: HandlerAuthURL
mkHandlerAuthURL =
  HandlerAuthURL
  { handlerAuthURLUrl = Nothing
  }

-- ** MicrosofttodoMigration
-- | MicrosofttodoMigration
data MicrosofttodoMigration = MicrosofttodoMigration
  { microsofttodoMigrationCode :: !(Maybe Text) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MicrosofttodoMigration
instance A.FromJSON MicrosofttodoMigration where
  parseJSON = A.withObject "MicrosofttodoMigration" $ \o ->
    MicrosofttodoMigration
      <$> (o .:? "code")

-- | ToJSON MicrosofttodoMigration
instance A.ToJSON MicrosofttodoMigration where
  toJSON MicrosofttodoMigration {..} =
   _omitNulls
      [ "code" .= microsofttodoMigrationCode
      ]


-- | Construct a value of type 'MicrosofttodoMigration' (by applying it's required fields, if any)
mkMicrosofttodoMigration
  :: MicrosofttodoMigration
mkMicrosofttodoMigration =
  MicrosofttodoMigration
  { microsofttodoMigrationCode = Nothing
  }

-- ** MigrationStatus
-- | MigrationStatus
data MigrationStatus = MigrationStatus
  { migrationStatusFinishedAt :: !(Maybe Text) -- ^ "finished_at"
  , migrationStatusId :: !(Maybe Int) -- ^ "id"
  , migrationStatusMigratorName :: !(Maybe Text) -- ^ "migrator_name"
  , migrationStatusStartedAt :: !(Maybe Text) -- ^ "started_at"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MigrationStatus
instance A.FromJSON MigrationStatus where
  parseJSON = A.withObject "MigrationStatus" $ \o ->
    MigrationStatus
      <$> (o .:? "finished_at")
      <*> (o .:? "id")
      <*> (o .:? "migrator_name")
      <*> (o .:? "started_at")

-- | ToJSON MigrationStatus
instance A.ToJSON MigrationStatus where
  toJSON MigrationStatus {..} =
   _omitNulls
      [ "finished_at" .= migrationStatusFinishedAt
      , "id" .= migrationStatusId
      , "migrator_name" .= migrationStatusMigratorName
      , "started_at" .= migrationStatusStartedAt
      ]


-- | Construct a value of type 'MigrationStatus' (by applying it's required fields, if any)
mkMigrationStatus
  :: MigrationStatus
mkMigrationStatus =
  MigrationStatus
  { migrationStatusFinishedAt = Nothing
  , migrationStatusId = Nothing
  , migrationStatusMigratorName = Nothing
  , migrationStatusStartedAt = Nothing
  }

-- ** ModelsAPIToken
-- | ModelsAPIToken
data ModelsAPIToken = ModelsAPIToken
  { modelsAPITokenCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this api key was created. You cannot change this value.
  , modelsAPITokenExpiresAt :: !(Maybe Text) -- ^ "expires_at" - The date when this key expires.
  , modelsAPITokenId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this api key.
  , modelsAPITokenPermissions :: !(Maybe (Map.Map String [Text])) -- ^ "permissions" - The permissions this token has. Possible values are available via the /routes endpoint and consist of the keys of the list from that endpoint. For example, if the token should be able to read all tasks as well as update existing tasks, you should add &#x60;{\&quot;tasks\&quot;:[\&quot;read_all\&quot;,\&quot;update\&quot;]}&#x60;.
  , modelsAPITokenTitle :: !(Maybe Text) -- ^ "title" - A human-readable name for this token
  , modelsAPITokenToken :: !(Maybe Text) -- ^ "token" - The actual api key. Only visible after creation.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsAPIToken
instance A.FromJSON ModelsAPIToken where
  parseJSON = A.withObject "ModelsAPIToken" $ \o ->
    ModelsAPIToken
      <$> (o .:? "created")
      <*> (o .:? "expires_at")
      <*> (o .:? "id")
      <*> (o .:? "permissions")
      <*> (o .:? "title")
      <*> (o .:? "token")

-- | ToJSON ModelsAPIToken
instance A.ToJSON ModelsAPIToken where
  toJSON ModelsAPIToken {..} =
   _omitNulls
      [ "created" .= modelsAPITokenCreated
      , "expires_at" .= modelsAPITokenExpiresAt
      , "id" .= modelsAPITokenId
      , "permissions" .= modelsAPITokenPermissions
      , "title" .= modelsAPITokenTitle
      , "token" .= modelsAPITokenToken
      ]


-- | Construct a value of type 'ModelsAPIToken' (by applying it's required fields, if any)
mkModelsAPIToken
  :: ModelsAPIToken
mkModelsAPIToken =
  ModelsAPIToken
  { modelsAPITokenCreated = Nothing
  , modelsAPITokenExpiresAt = Nothing
  , modelsAPITokenId = Nothing
  , modelsAPITokenPermissions = Nothing
  , modelsAPITokenTitle = Nothing
  , modelsAPITokenToken = Nothing
  }

-- ** ModelsBucket
-- | ModelsBucket
data ModelsBucket = ModelsBucket
  { modelsBucketCount :: !(Maybe Int) -- ^ "count" - The number of tasks currently in this bucket
  , modelsBucketCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this bucket was created. You cannot change this value.
  , modelsBucketCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who initially created the bucket.
  , modelsBucketId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this bucket.
  , modelsBucketLimit :: !(Maybe Int) -- ^ "limit" - How many tasks can be at the same time on this board max
  , modelsBucketPosition :: !(Maybe Double) -- ^ "position" - The position this bucket has when querying all buckets. See the tasks.position property on how to use this.
  , modelsBucketProjectViewId :: !(Maybe Int) -- ^ "project_view_id" - The project view this bucket belongs to.
  , modelsBucketTasks :: !(Maybe [ModelsTask]) -- ^ "tasks" - All tasks which belong to this bucket.
  , modelsBucketTitle :: !(Maybe Text) -- ^ "title" - The title of this bucket.
  , modelsBucketUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this bucket was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsBucket
instance A.FromJSON ModelsBucket where
  parseJSON = A.withObject "ModelsBucket" $ \o ->
    ModelsBucket
      <$> (o .:? "count")
      <*> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "id")
      <*> (o .:? "limit")
      <*> (o .:? "position")
      <*> (o .:? "project_view_id")
      <*> (o .:? "tasks")
      <*> (o .:? "title")
      <*> (o .:? "updated")

-- | ToJSON ModelsBucket
instance A.ToJSON ModelsBucket where
  toJSON ModelsBucket {..} =
   _omitNulls
      [ "count" .= modelsBucketCount
      , "created" .= modelsBucketCreated
      , "created_by" .= modelsBucketCreatedBy
      , "id" .= modelsBucketId
      , "limit" .= modelsBucketLimit
      , "position" .= modelsBucketPosition
      , "project_view_id" .= modelsBucketProjectViewId
      , "tasks" .= modelsBucketTasks
      , "title" .= modelsBucketTitle
      , "updated" .= modelsBucketUpdated
      ]


-- | Construct a value of type 'ModelsBucket' (by applying it's required fields, if any)
mkModelsBucket
  :: ModelsBucket
mkModelsBucket =
  ModelsBucket
  { modelsBucketCount = Nothing
  , modelsBucketCreated = Nothing
  , modelsBucketCreatedBy = Nothing
  , modelsBucketId = Nothing
  , modelsBucketLimit = Nothing
  , modelsBucketPosition = Nothing
  , modelsBucketProjectViewId = Nothing
  , modelsBucketTasks = Nothing
  , modelsBucketTitle = Nothing
  , modelsBucketUpdated = Nothing
  }

-- ** ModelsBulkAssignees
-- | ModelsBulkAssignees
data ModelsBulkAssignees = ModelsBulkAssignees
  { modelsBulkAssigneesAssignees :: !(Maybe [UserUser]) -- ^ "assignees" - A project with all assignees
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsBulkAssignees
instance A.FromJSON ModelsBulkAssignees where
  parseJSON = A.withObject "ModelsBulkAssignees" $ \o ->
    ModelsBulkAssignees
      <$> (o .:? "assignees")

-- | ToJSON ModelsBulkAssignees
instance A.ToJSON ModelsBulkAssignees where
  toJSON ModelsBulkAssignees {..} =
   _omitNulls
      [ "assignees" .= modelsBulkAssigneesAssignees
      ]


-- | Construct a value of type 'ModelsBulkAssignees' (by applying it's required fields, if any)
mkModelsBulkAssignees
  :: ModelsBulkAssignees
mkModelsBulkAssignees =
  ModelsBulkAssignees
  { modelsBulkAssigneesAssignees = Nothing
  }

-- ** ModelsBulkTask
-- | ModelsBulkTask
data ModelsBulkTask = ModelsBulkTask
  { modelsBulkTaskAssignees :: !(Maybe [UserUser]) -- ^ "assignees" - An array of users who are assigned to this task
  , modelsBulkTaskAttachments :: !(Maybe [ModelsTaskAttachment]) -- ^ "attachments" - All attachments this task has. This property is read-onlym, you must use the separate endpoint to add attachments to a task.
  , modelsBulkTaskBucketId :: !(Maybe Int) -- ^ "bucket_id" - The bucket id. Will only be populated when the task is accessed via a view with buckets. Can be used to move a task between buckets. In that case, the new bucket must be in the same view as the old one.
  , modelsBulkTaskCoverImageAttachmentId :: !(Maybe Int) -- ^ "cover_image_attachment_id" - If this task has a cover image, the field will return the id of the attachment that is the cover image.
  , modelsBulkTaskCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this task was created. You cannot change this value.
  , modelsBulkTaskCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who initially created the task.
  , modelsBulkTaskDescription :: !(Maybe Text) -- ^ "description" - The task description.
  , modelsBulkTaskDone :: !(Maybe Bool) -- ^ "done" - Whether a task is done or not.
  , modelsBulkTaskDoneAt :: !(Maybe Text) -- ^ "done_at" - The time when a task was marked as done.
  , modelsBulkTaskDueDate :: !(Maybe Text) -- ^ "due_date" - The time when the task is due.
  , modelsBulkTaskEndDate :: !(Maybe Text) -- ^ "end_date" - When this task ends.
  , modelsBulkTaskHexColor :: !(Maybe Text) -- ^ "hex_color" - The task color in hex
  , modelsBulkTaskId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this task.
  , modelsBulkTaskIdentifier :: !(Maybe Text) -- ^ "identifier" - The task identifier, based on the project identifier and the task&#39;s index
  , modelsBulkTaskIndex :: !(Maybe Int) -- ^ "index" - The task index, calculated per project
  , modelsBulkTaskIsFavorite :: !(Maybe Bool) -- ^ "is_favorite" - True if a task is a favorite task. Favorite tasks show up in a separate \&quot;Important\&quot; project. This value depends on the user making the call to the api.
  , modelsBulkTaskLabels :: !(Maybe [ModelsLabel]) -- ^ "labels" - An array of labels which are associated with this task. This property is read-only, you must use the separate endpoint to add labels to a task.
  , modelsBulkTaskPercentDone :: !(Maybe Double) -- ^ "percent_done" - Determines how far a task is left from being done
  , modelsBulkTaskPosition :: !(Maybe Double) -- ^ "position" - The position of the task - any task project can be sorted as usual by this parameter. When accessing tasks via views with buckets, this is primarily used to sort them based on a range. Positions are always saved per view. They will automatically be set if you request the tasks through a view endpoint, otherwise they will always be 0. To update them, take a look at the Task Position endpoint.
  , modelsBulkTaskPriority :: !(Maybe Int) -- ^ "priority" - The task priority. Can be anything you want, it is possible to sort by this later.
  , modelsBulkTaskProjectId :: !(Maybe Int) -- ^ "project_id" - The project this task belongs to.
  , modelsBulkTaskReactions :: !(Maybe (Map.Map String [UserUser])) -- ^ "reactions" - Reactions on that task.
  , modelsBulkTaskRelatedTasks :: !(Maybe (Map.Map String [ModelsTask])) -- ^ "related_tasks" - All related tasks, grouped by their relation kind
  , modelsBulkTaskReminders :: !(Maybe [ModelsTaskReminder]) -- ^ "reminders" - An array of reminders that are associated with this task.
  , modelsBulkTaskRepeatAfter :: !(Maybe Int) -- ^ "repeat_after" - An amount in seconds this task repeats itself. If this is set, when marking the task as done, it will mark itself as \&quot;undone\&quot; and then increase all remindes and the due date by its amount.
  , modelsBulkTaskRepeatMode :: !(Maybe ModelsTaskRepeatMode) -- ^ "repeat_mode" - Can have three possible values which will trigger when the task is marked as done: 0 &#x3D; repeats after the amount specified in repeat_after, 1 &#x3D; repeats all dates each months (ignoring repeat_after), 3 &#x3D; repeats from the current date rather than the last set date.
  , modelsBulkTaskStartDate :: !(Maybe Text) -- ^ "start_date" - When this task starts.
  , modelsBulkTaskSubscription :: !(Maybe ModelsSubscription) -- ^ "subscription" - The subscription status for the user reading this task. You can only read this property, use the subscription endpoints to modify it. Will only returned when retrieving one task.
  , modelsBulkTaskTaskIds :: !(Maybe [Int]) -- ^ "task_ids" - A project of task ids to update
  , modelsBulkTaskTitle :: !(Maybe Text) -- ^ "title" - The task text. This is what you&#39;ll see in the project.
  , modelsBulkTaskUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this task was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsBulkTask
instance A.FromJSON ModelsBulkTask where
  parseJSON = A.withObject "ModelsBulkTask" $ \o ->
    ModelsBulkTask
      <$> (o .:? "assignees")
      <*> (o .:? "attachments")
      <*> (o .:? "bucket_id")
      <*> (o .:? "cover_image_attachment_id")
      <*> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "description")
      <*> (o .:? "done")
      <*> (o .:? "done_at")
      <*> (o .:? "due_date")
      <*> (o .:? "end_date")
      <*> (o .:? "hex_color")
      <*> (o .:? "id")
      <*> (o .:? "identifier")
      <*> (o .:? "index")
      <*> (o .:? "is_favorite")
      <*> (o .:? "labels")
      <*> (o .:? "percent_done")
      <*> (o .:? "position")
      <*> (o .:? "priority")
      <*> (o .:? "project_id")
      <*> (o .:? "reactions")
      <*> (o .:? "related_tasks")
      <*> (o .:? "reminders")
      <*> (o .:? "repeat_after")
      <*> (o .:? "repeat_mode")
      <*> (o .:? "start_date")
      <*> (o .:? "subscription")
      <*> (o .:? "task_ids")
      <*> (o .:? "title")
      <*> (o .:? "updated")

-- | ToJSON ModelsBulkTask
instance A.ToJSON ModelsBulkTask where
  toJSON ModelsBulkTask {..} =
   _omitNulls
      [ "assignees" .= modelsBulkTaskAssignees
      , "attachments" .= modelsBulkTaskAttachments
      , "bucket_id" .= modelsBulkTaskBucketId
      , "cover_image_attachment_id" .= modelsBulkTaskCoverImageAttachmentId
      , "created" .= modelsBulkTaskCreated
      , "created_by" .= modelsBulkTaskCreatedBy
      , "description" .= modelsBulkTaskDescription
      , "done" .= modelsBulkTaskDone
      , "done_at" .= modelsBulkTaskDoneAt
      , "due_date" .= modelsBulkTaskDueDate
      , "end_date" .= modelsBulkTaskEndDate
      , "hex_color" .= modelsBulkTaskHexColor
      , "id" .= modelsBulkTaskId
      , "identifier" .= modelsBulkTaskIdentifier
      , "index" .= modelsBulkTaskIndex
      , "is_favorite" .= modelsBulkTaskIsFavorite
      , "labels" .= modelsBulkTaskLabels
      , "percent_done" .= modelsBulkTaskPercentDone
      , "position" .= modelsBulkTaskPosition
      , "priority" .= modelsBulkTaskPriority
      , "project_id" .= modelsBulkTaskProjectId
      , "reactions" .= modelsBulkTaskReactions
      , "related_tasks" .= modelsBulkTaskRelatedTasks
      , "reminders" .= modelsBulkTaskReminders
      , "repeat_after" .= modelsBulkTaskRepeatAfter
      , "repeat_mode" .= modelsBulkTaskRepeatMode
      , "start_date" .= modelsBulkTaskStartDate
      , "subscription" .= modelsBulkTaskSubscription
      , "task_ids" .= modelsBulkTaskTaskIds
      , "title" .= modelsBulkTaskTitle
      , "updated" .= modelsBulkTaskUpdated
      ]


-- | Construct a value of type 'ModelsBulkTask' (by applying it's required fields, if any)
mkModelsBulkTask
  :: ModelsBulkTask
mkModelsBulkTask =
  ModelsBulkTask
  { modelsBulkTaskAssignees = Nothing
  , modelsBulkTaskAttachments = Nothing
  , modelsBulkTaskBucketId = Nothing
  , modelsBulkTaskCoverImageAttachmentId = Nothing
  , modelsBulkTaskCreated = Nothing
  , modelsBulkTaskCreatedBy = Nothing
  , modelsBulkTaskDescription = Nothing
  , modelsBulkTaskDone = Nothing
  , modelsBulkTaskDoneAt = Nothing
  , modelsBulkTaskDueDate = Nothing
  , modelsBulkTaskEndDate = Nothing
  , modelsBulkTaskHexColor = Nothing
  , modelsBulkTaskId = Nothing
  , modelsBulkTaskIdentifier = Nothing
  , modelsBulkTaskIndex = Nothing
  , modelsBulkTaskIsFavorite = Nothing
  , modelsBulkTaskLabels = Nothing
  , modelsBulkTaskPercentDone = Nothing
  , modelsBulkTaskPosition = Nothing
  , modelsBulkTaskPriority = Nothing
  , modelsBulkTaskProjectId = Nothing
  , modelsBulkTaskReactions = Nothing
  , modelsBulkTaskRelatedTasks = Nothing
  , modelsBulkTaskReminders = Nothing
  , modelsBulkTaskRepeatAfter = Nothing
  , modelsBulkTaskRepeatMode = Nothing
  , modelsBulkTaskStartDate = Nothing
  , modelsBulkTaskSubscription = Nothing
  , modelsBulkTaskTaskIds = Nothing
  , modelsBulkTaskTitle = Nothing
  , modelsBulkTaskUpdated = Nothing
  }

-- ** ModelsDatabaseNotifications
-- | ModelsDatabaseNotifications
data ModelsDatabaseNotifications = ModelsDatabaseNotifications
  { modelsDatabaseNotificationsCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this notification was created. You cannot change this value.
  , modelsDatabaseNotificationsId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this notification.
  , modelsDatabaseNotificationsName :: !(Maybe Text) -- ^ "name" - The name of the notification
  , modelsDatabaseNotificationsNotification :: !(Maybe A.Value) -- ^ "notification" - The actual content of the notification.
  , modelsDatabaseNotificationsRead :: !(Maybe Bool) -- ^ "read" - Whether or not to mark this notification as read or unread. True is read, false is unread.
  , modelsDatabaseNotificationsReadAt :: !(Maybe Text) -- ^ "read_at" - When this notification is marked as read, this will be updated with the current timestamp.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsDatabaseNotifications
instance A.FromJSON ModelsDatabaseNotifications where
  parseJSON = A.withObject "ModelsDatabaseNotifications" $ \o ->
    ModelsDatabaseNotifications
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "notification")
      <*> (o .:? "read")
      <*> (o .:? "read_at")

-- | ToJSON ModelsDatabaseNotifications
instance A.ToJSON ModelsDatabaseNotifications where
  toJSON ModelsDatabaseNotifications {..} =
   _omitNulls
      [ "created" .= modelsDatabaseNotificationsCreated
      , "id" .= modelsDatabaseNotificationsId
      , "name" .= modelsDatabaseNotificationsName
      , "notification" .= modelsDatabaseNotificationsNotification
      , "read" .= modelsDatabaseNotificationsRead
      , "read_at" .= modelsDatabaseNotificationsReadAt
      ]


-- | Construct a value of type 'ModelsDatabaseNotifications' (by applying it's required fields, if any)
mkModelsDatabaseNotifications
  :: ModelsDatabaseNotifications
mkModelsDatabaseNotifications =
  ModelsDatabaseNotifications
  { modelsDatabaseNotificationsCreated = Nothing
  , modelsDatabaseNotificationsId = Nothing
  , modelsDatabaseNotificationsName = Nothing
  , modelsDatabaseNotificationsNotification = Nothing
  , modelsDatabaseNotificationsRead = Nothing
  , modelsDatabaseNotificationsReadAt = Nothing
  }

-- ** ModelsLabel
-- | ModelsLabel
data ModelsLabel = ModelsLabel
  { modelsLabelCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this label was created. You cannot change this value.
  , modelsLabelCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who created this label
  , modelsLabelDescription :: !(Maybe Text) -- ^ "description" - The label description.
  , modelsLabelHexColor :: !(Maybe Text) -- ^ "hex_color" - The color this label has in hex format.
  , modelsLabelId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this label.
  , modelsLabelTitle :: !(Maybe Text) -- ^ "title" - The title of the lable. You&#39;ll see this one on tasks associated with it.
  , modelsLabelUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this label was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsLabel
instance A.FromJSON ModelsLabel where
  parseJSON = A.withObject "ModelsLabel" $ \o ->
    ModelsLabel
      <$> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "description")
      <*> (o .:? "hex_color")
      <*> (o .:? "id")
      <*> (o .:? "title")
      <*> (o .:? "updated")

-- | ToJSON ModelsLabel
instance A.ToJSON ModelsLabel where
  toJSON ModelsLabel {..} =
   _omitNulls
      [ "created" .= modelsLabelCreated
      , "created_by" .= modelsLabelCreatedBy
      , "description" .= modelsLabelDescription
      , "hex_color" .= modelsLabelHexColor
      , "id" .= modelsLabelId
      , "title" .= modelsLabelTitle
      , "updated" .= modelsLabelUpdated
      ]


-- | Construct a value of type 'ModelsLabel' (by applying it's required fields, if any)
mkModelsLabel
  :: ModelsLabel
mkModelsLabel =
  ModelsLabel
  { modelsLabelCreated = Nothing
  , modelsLabelCreatedBy = Nothing
  , modelsLabelDescription = Nothing
  , modelsLabelHexColor = Nothing
  , modelsLabelId = Nothing
  , modelsLabelTitle = Nothing
  , modelsLabelUpdated = Nothing
  }

-- ** ModelsLabelTask
-- | ModelsLabelTask
data ModelsLabelTask = ModelsLabelTask
  { modelsLabelTaskCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this task was created. You cannot change this value.
  , modelsLabelTaskLabelId :: !(Maybe Int) -- ^ "label_id" - The label id you want to associate with a task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsLabelTask
instance A.FromJSON ModelsLabelTask where
  parseJSON = A.withObject "ModelsLabelTask" $ \o ->
    ModelsLabelTask
      <$> (o .:? "created")
      <*> (o .:? "label_id")

-- | ToJSON ModelsLabelTask
instance A.ToJSON ModelsLabelTask where
  toJSON ModelsLabelTask {..} =
   _omitNulls
      [ "created" .= modelsLabelTaskCreated
      , "label_id" .= modelsLabelTaskLabelId
      ]


-- | Construct a value of type 'ModelsLabelTask' (by applying it's required fields, if any)
mkModelsLabelTask
  :: ModelsLabelTask
mkModelsLabelTask =
  ModelsLabelTask
  { modelsLabelTaskCreated = Nothing
  , modelsLabelTaskLabelId = Nothing
  }

-- ** ModelsLabelTaskBulk
-- | ModelsLabelTaskBulk
data ModelsLabelTaskBulk = ModelsLabelTaskBulk
  { modelsLabelTaskBulkLabels :: !(Maybe [ModelsLabel]) -- ^ "labels" - All labels you want to update at once.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsLabelTaskBulk
instance A.FromJSON ModelsLabelTaskBulk where
  parseJSON = A.withObject "ModelsLabelTaskBulk" $ \o ->
    ModelsLabelTaskBulk
      <$> (o .:? "labels")

-- | ToJSON ModelsLabelTaskBulk
instance A.ToJSON ModelsLabelTaskBulk where
  toJSON ModelsLabelTaskBulk {..} =
   _omitNulls
      [ "labels" .= modelsLabelTaskBulkLabels
      ]


-- | Construct a value of type 'ModelsLabelTaskBulk' (by applying it's required fields, if any)
mkModelsLabelTaskBulk
  :: ModelsLabelTaskBulk
mkModelsLabelTaskBulk =
  ModelsLabelTaskBulk
  { modelsLabelTaskBulkLabels = Nothing
  }

-- ** ModelsLinkSharing
-- | ModelsLinkSharing
data ModelsLinkSharing = ModelsLinkSharing
  { modelsLinkSharingCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this project was shared. You cannot change this value.
  , modelsLinkSharingHash :: !(Maybe Text) -- ^ "hash" - The public id to get this shared project
  , modelsLinkSharingId :: !(Maybe Int) -- ^ "id" - The ID of the shared thing
  , modelsLinkSharingName :: !(Maybe Text) -- ^ "name" - The name of this link share. All actions someone takes while being authenticated with that link will appear with that name.
  , modelsLinkSharingPassword :: !(Maybe Text) -- ^ "password" - The password of this link share. You can only set it, not retrieve it after the link share has been created.
  , modelsLinkSharingRight :: !(Maybe ModelsRight) -- ^ "right" - The right this project is shared with. 0 &#x3D; Read only, 1 &#x3D; Read &amp; Write, 2 &#x3D; Admin. See the docs for more details.
  , modelsLinkSharingSharedBy :: !(Maybe UserUser) -- ^ "shared_by" - The user who shared this project
  , modelsLinkSharingSharingType :: !(Maybe ModelsSharingType) -- ^ "sharing_type" - The kind of this link. 0 &#x3D; undefined, 1 &#x3D; without password, 2 &#x3D; with password.
  , modelsLinkSharingUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this share was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsLinkSharing
instance A.FromJSON ModelsLinkSharing where
  parseJSON = A.withObject "ModelsLinkSharing" $ \o ->
    ModelsLinkSharing
      <$> (o .:? "created")
      <*> (o .:? "hash")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "password")
      <*> (o .:? "right")
      <*> (o .:? "shared_by")
      <*> (o .:? "sharing_type")
      <*> (o .:? "updated")

-- | ToJSON ModelsLinkSharing
instance A.ToJSON ModelsLinkSharing where
  toJSON ModelsLinkSharing {..} =
   _omitNulls
      [ "created" .= modelsLinkSharingCreated
      , "hash" .= modelsLinkSharingHash
      , "id" .= modelsLinkSharingId
      , "name" .= modelsLinkSharingName
      , "password" .= modelsLinkSharingPassword
      , "right" .= modelsLinkSharingRight
      , "shared_by" .= modelsLinkSharingSharedBy
      , "sharing_type" .= modelsLinkSharingSharingType
      , "updated" .= modelsLinkSharingUpdated
      ]


-- | Construct a value of type 'ModelsLinkSharing' (by applying it's required fields, if any)
mkModelsLinkSharing
  :: ModelsLinkSharing
mkModelsLinkSharing =
  ModelsLinkSharing
  { modelsLinkSharingCreated = Nothing
  , modelsLinkSharingHash = Nothing
  , modelsLinkSharingId = Nothing
  , modelsLinkSharingName = Nothing
  , modelsLinkSharingPassword = Nothing
  , modelsLinkSharingRight = Nothing
  , modelsLinkSharingSharedBy = Nothing
  , modelsLinkSharingSharingType = Nothing
  , modelsLinkSharingUpdated = Nothing
  }

-- ** ModelsMessage
-- | ModelsMessage
data ModelsMessage = ModelsMessage
  { modelsMessageMessage :: !(Maybe Text) -- ^ "message" - A standard message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsMessage
instance A.FromJSON ModelsMessage where
  parseJSON = A.withObject "ModelsMessage" $ \o ->
    ModelsMessage
      <$> (o .:? "message")

-- | ToJSON ModelsMessage
instance A.ToJSON ModelsMessage where
  toJSON ModelsMessage {..} =
   _omitNulls
      [ "message" .= modelsMessageMessage
      ]


-- | Construct a value of type 'ModelsMessage' (by applying it's required fields, if any)
mkModelsMessage
  :: ModelsMessage
mkModelsMessage =
  ModelsMessage
  { modelsMessageMessage = Nothing
  }

-- ** ModelsProject
-- | ModelsProject
data ModelsProject = ModelsProject
  { modelsProjectBackgroundBlurHash :: !(Maybe Text) -- ^ "background_blur_hash" - Contains a very small version of the project background to use as a blurry preview until the actual background is loaded. Check out https://blurha.sh/ to learn how it works.
  , modelsProjectBackgroundInformation :: !(Maybe A.Value) -- ^ "background_information" - Holds extra information about the background set since some background providers require attribution or similar. If not null, the background can be accessed at /projects/{projectID}/background
  , modelsProjectCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this project was created. You cannot change this value.
  , modelsProjectDescription :: !(Maybe Text) -- ^ "description" - The description of the project.
  , modelsProjectHexColor :: !(Maybe Text) -- ^ "hex_color" - The hex color of this project
  , modelsProjectId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this project.
  , modelsProjectIdentifier :: !(Maybe Text) -- ^ "identifier" - The unique project short identifier. Used to build task identifiers.
  , modelsProjectIsArchived :: !(Maybe Bool) -- ^ "is_archived" - Whether a project is archived.
  , modelsProjectIsFavorite :: !(Maybe Bool) -- ^ "is_favorite" - True if a project is a favorite. Favorite projects show up in a separate parent project. This value depends on the user making the call to the api.
  , modelsProjectOwner :: !(Maybe UserUser) -- ^ "owner" - The user who created this project.
  , modelsProjectParentProjectId :: !(Maybe Int) -- ^ "parent_project_id"
  , modelsProjectPosition :: !(Maybe Double) -- ^ "position" - The position this project has when querying all projects. See the tasks.position property on how to use this.
  , modelsProjectSubscription :: !(Maybe ModelsSubscription) -- ^ "subscription" - The subscription status for the user reading this project. You can only read this property, use the subscription endpoints to modify it. Will only returned when retreiving one project.
  , modelsProjectTitle :: !(Maybe Text) -- ^ "title" - The title of the project. You&#39;ll see this in the overview.
  , modelsProjectUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this project was last updated. You cannot change this value.
  , modelsProjectViews :: !(Maybe [ModelsProjectView]) -- ^ "views"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsProject
instance A.FromJSON ModelsProject where
  parseJSON = A.withObject "ModelsProject" $ \o ->
    ModelsProject
      <$> (o .:? "background_blur_hash")
      <*> (o .:? "background_information")
      <*> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "hex_color")
      <*> (o .:? "id")
      <*> (o .:? "identifier")
      <*> (o .:? "is_archived")
      <*> (o .:? "is_favorite")
      <*> (o .:? "owner")
      <*> (o .:? "parent_project_id")
      <*> (o .:? "position")
      <*> (o .:? "subscription")
      <*> (o .:? "title")
      <*> (o .:? "updated")
      <*> (o .:? "views")

-- | ToJSON ModelsProject
instance A.ToJSON ModelsProject where
  toJSON ModelsProject {..} =
   _omitNulls
      [ "background_blur_hash" .= modelsProjectBackgroundBlurHash
      , "background_information" .= modelsProjectBackgroundInformation
      , "created" .= modelsProjectCreated
      , "description" .= modelsProjectDescription
      , "hex_color" .= modelsProjectHexColor
      , "id" .= modelsProjectId
      , "identifier" .= modelsProjectIdentifier
      , "is_archived" .= modelsProjectIsArchived
      , "is_favorite" .= modelsProjectIsFavorite
      , "owner" .= modelsProjectOwner
      , "parent_project_id" .= modelsProjectParentProjectId
      , "position" .= modelsProjectPosition
      , "subscription" .= modelsProjectSubscription
      , "title" .= modelsProjectTitle
      , "updated" .= modelsProjectUpdated
      , "views" .= modelsProjectViews
      ]


-- | Construct a value of type 'ModelsProject' (by applying it's required fields, if any)
mkModelsProject
  :: ModelsProject
mkModelsProject =
  ModelsProject
  { modelsProjectBackgroundBlurHash = Nothing
  , modelsProjectBackgroundInformation = Nothing
  , modelsProjectCreated = Nothing
  , modelsProjectDescription = Nothing
  , modelsProjectHexColor = Nothing
  , modelsProjectId = Nothing
  , modelsProjectIdentifier = Nothing
  , modelsProjectIsArchived = Nothing
  , modelsProjectIsFavorite = Nothing
  , modelsProjectOwner = Nothing
  , modelsProjectParentProjectId = Nothing
  , modelsProjectPosition = Nothing
  , modelsProjectSubscription = Nothing
  , modelsProjectTitle = Nothing
  , modelsProjectUpdated = Nothing
  , modelsProjectViews = Nothing
  }

-- ** ModelsProjectDuplicate
-- | ModelsProjectDuplicate
data ModelsProjectDuplicate = ModelsProjectDuplicate
  { modelsProjectDuplicateDuplicatedProject :: !(Maybe ModelsProject) -- ^ "duplicated_project" - The copied project
  , modelsProjectDuplicateParentProjectId :: !(Maybe Int) -- ^ "parent_project_id" - The target parent project
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsProjectDuplicate
instance A.FromJSON ModelsProjectDuplicate where
  parseJSON = A.withObject "ModelsProjectDuplicate" $ \o ->
    ModelsProjectDuplicate
      <$> (o .:? "duplicated_project")
      <*> (o .:? "parent_project_id")

-- | ToJSON ModelsProjectDuplicate
instance A.ToJSON ModelsProjectDuplicate where
  toJSON ModelsProjectDuplicate {..} =
   _omitNulls
      [ "duplicated_project" .= modelsProjectDuplicateDuplicatedProject
      , "parent_project_id" .= modelsProjectDuplicateParentProjectId
      ]


-- | Construct a value of type 'ModelsProjectDuplicate' (by applying it's required fields, if any)
mkModelsProjectDuplicate
  :: ModelsProjectDuplicate
mkModelsProjectDuplicate =
  ModelsProjectDuplicate
  { modelsProjectDuplicateDuplicatedProject = Nothing
  , modelsProjectDuplicateParentProjectId = Nothing
  }

-- ** ModelsProjectUser
-- | ModelsProjectUser
data ModelsProjectUser = ModelsProjectUser
  { modelsProjectUserCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this relation was created. You cannot change this value.
  , modelsProjectUserId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this project &lt;-&gt; user relation.
  , modelsProjectUserRight :: !(Maybe ModelsRight) -- ^ "right" - The right this user has. 0 &#x3D; Read only, 1 &#x3D; Read &amp; Write, 2 &#x3D; Admin. See the docs for more details.
  , modelsProjectUserUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this relation was last updated. You cannot change this value.
  , modelsProjectUserUserId :: !(Maybe Text) -- ^ "user_id" - The username.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsProjectUser
instance A.FromJSON ModelsProjectUser where
  parseJSON = A.withObject "ModelsProjectUser" $ \o ->
    ModelsProjectUser
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "right")
      <*> (o .:? "updated")
      <*> (o .:? "user_id")

-- | ToJSON ModelsProjectUser
instance A.ToJSON ModelsProjectUser where
  toJSON ModelsProjectUser {..} =
   _omitNulls
      [ "created" .= modelsProjectUserCreated
      , "id" .= modelsProjectUserId
      , "right" .= modelsProjectUserRight
      , "updated" .= modelsProjectUserUpdated
      , "user_id" .= modelsProjectUserUserId
      ]


-- | Construct a value of type 'ModelsProjectUser' (by applying it's required fields, if any)
mkModelsProjectUser
  :: ModelsProjectUser
mkModelsProjectUser =
  ModelsProjectUser
  { modelsProjectUserCreated = Nothing
  , modelsProjectUserId = Nothing
  , modelsProjectUserRight = Nothing
  , modelsProjectUserUpdated = Nothing
  , modelsProjectUserUserId = Nothing
  }

-- ** ModelsProjectView
-- | ModelsProjectView
data ModelsProjectView = ModelsProjectView
  { modelsProjectViewBucketConfiguration :: !(Maybe [ModelsProjectViewBucketConfiguration]) -- ^ "bucket_configuration" - When the bucket configuration mode is not &#x60;manual&#x60;, this field holds the options of that configuration.
  , modelsProjectViewBucketConfigurationMode :: !(Maybe ModelsBucketConfigurationModeKind) -- ^ "bucket_configuration_mode" - The bucket configuration mode. Can be &#x60;none&#x60;, &#x60;manual&#x60; or &#x60;filter&#x60;. &#x60;manual&#x60; allows to move tasks between buckets as you normally would. &#x60;filter&#x60; creates buckets based on a filter for each bucket.
  , modelsProjectViewCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this reaction was created. You cannot change this value.
  , modelsProjectViewDefaultBucketId :: !(Maybe Int) -- ^ "default_bucket_id" - The ID of the bucket where new tasks without a bucket are added to. By default, this is the leftmost bucket in a view.
  , modelsProjectViewDoneBucketId :: !(Maybe Int) -- ^ "done_bucket_id" - If tasks are moved to the done bucket, they are marked as done. If they are marked as done individually, they are moved into the done bucket.
  , modelsProjectViewFilter :: !(Maybe Text) -- ^ "filter" - The filter query to match tasks by. Check out https://vikunja.io/docs/filters for a full explanation.
  , modelsProjectViewId :: !(Maybe Int) -- ^ "id" - The unique numeric id of this view
  , modelsProjectViewPosition :: !(Maybe Double) -- ^ "position" - The position of this view in the list. The list of all views will be sorted by this parameter.
  , modelsProjectViewProjectId :: !(Maybe Int) -- ^ "project_id" - The project this view belongs to
  , modelsProjectViewTitle :: !(Maybe Text) -- ^ "title" - The title of this view
  , modelsProjectViewUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this view was updated. You cannot change this value.
  , modelsProjectViewViewKind :: !(Maybe ModelsProjectViewKind) -- ^ "view_kind" - The kind of this view. Can be &#x60;list&#x60;, &#x60;gantt&#x60;, &#x60;table&#x60; or &#x60;kanban&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsProjectView
instance A.FromJSON ModelsProjectView where
  parseJSON = A.withObject "ModelsProjectView" $ \o ->
    ModelsProjectView
      <$> (o .:? "bucket_configuration")
      <*> (o .:? "bucket_configuration_mode")
      <*> (o .:? "created")
      <*> (o .:? "default_bucket_id")
      <*> (o .:? "done_bucket_id")
      <*> (o .:? "filter")
      <*> (o .:? "id")
      <*> (o .:? "position")
      <*> (o .:? "project_id")
      <*> (o .:? "title")
      <*> (o .:? "updated")
      <*> (o .:? "view_kind")

-- | ToJSON ModelsProjectView
instance A.ToJSON ModelsProjectView where
  toJSON ModelsProjectView {..} =
   _omitNulls
      [ "bucket_configuration" .= modelsProjectViewBucketConfiguration
      , "bucket_configuration_mode" .= modelsProjectViewBucketConfigurationMode
      , "created" .= modelsProjectViewCreated
      , "default_bucket_id" .= modelsProjectViewDefaultBucketId
      , "done_bucket_id" .= modelsProjectViewDoneBucketId
      , "filter" .= modelsProjectViewFilter
      , "id" .= modelsProjectViewId
      , "position" .= modelsProjectViewPosition
      , "project_id" .= modelsProjectViewProjectId
      , "title" .= modelsProjectViewTitle
      , "updated" .= modelsProjectViewUpdated
      , "view_kind" .= modelsProjectViewViewKind
      ]


-- | Construct a value of type 'ModelsProjectView' (by applying it's required fields, if any)
mkModelsProjectView
  :: ModelsProjectView
mkModelsProjectView =
  ModelsProjectView
  { modelsProjectViewBucketConfiguration = Nothing
  , modelsProjectViewBucketConfigurationMode = Nothing
  , modelsProjectViewCreated = Nothing
  , modelsProjectViewDefaultBucketId = Nothing
  , modelsProjectViewDoneBucketId = Nothing
  , modelsProjectViewFilter = Nothing
  , modelsProjectViewId = Nothing
  , modelsProjectViewPosition = Nothing
  , modelsProjectViewProjectId = Nothing
  , modelsProjectViewTitle = Nothing
  , modelsProjectViewUpdated = Nothing
  , modelsProjectViewViewKind = Nothing
  }

-- ** ModelsProjectViewBucketConfiguration
-- | ModelsProjectViewBucketConfiguration
data ModelsProjectViewBucketConfiguration = ModelsProjectViewBucketConfiguration
  { modelsProjectViewBucketConfigurationFilter :: !(Maybe Text) -- ^ "filter"
  , modelsProjectViewBucketConfigurationTitle :: !(Maybe Text) -- ^ "title"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsProjectViewBucketConfiguration
instance A.FromJSON ModelsProjectViewBucketConfiguration where
  parseJSON = A.withObject "ModelsProjectViewBucketConfiguration" $ \o ->
    ModelsProjectViewBucketConfiguration
      <$> (o .:? "filter")
      <*> (o .:? "title")

-- | ToJSON ModelsProjectViewBucketConfiguration
instance A.ToJSON ModelsProjectViewBucketConfiguration where
  toJSON ModelsProjectViewBucketConfiguration {..} =
   _omitNulls
      [ "filter" .= modelsProjectViewBucketConfigurationFilter
      , "title" .= modelsProjectViewBucketConfigurationTitle
      ]


-- | Construct a value of type 'ModelsProjectViewBucketConfiguration' (by applying it's required fields, if any)
mkModelsProjectViewBucketConfiguration
  :: ModelsProjectViewBucketConfiguration
mkModelsProjectViewBucketConfiguration =
  ModelsProjectViewBucketConfiguration
  { modelsProjectViewBucketConfigurationFilter = Nothing
  , modelsProjectViewBucketConfigurationTitle = Nothing
  }

-- ** ModelsReaction
-- | ModelsReaction
data ModelsReaction = ModelsReaction
  { modelsReactionCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this reaction was created. You cannot change this value.
  , modelsReactionUser :: !(Maybe UserUser) -- ^ "user" - The user who reacted
  , modelsReactionValue :: !(Maybe Text) -- ^ "value" - The actual reaction. This can be any valid utf character or text, up to a length of 20.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsReaction
instance A.FromJSON ModelsReaction where
  parseJSON = A.withObject "ModelsReaction" $ \o ->
    ModelsReaction
      <$> (o .:? "created")
      <*> (o .:? "user")
      <*> (o .:? "value")

-- | ToJSON ModelsReaction
instance A.ToJSON ModelsReaction where
  toJSON ModelsReaction {..} =
   _omitNulls
      [ "created" .= modelsReactionCreated
      , "user" .= modelsReactionUser
      , "value" .= modelsReactionValue
      ]


-- | Construct a value of type 'ModelsReaction' (by applying it's required fields, if any)
mkModelsReaction
  :: ModelsReaction
mkModelsReaction =
  ModelsReaction
  { modelsReactionCreated = Nothing
  , modelsReactionUser = Nothing
  , modelsReactionValue = Nothing
  }

-- ** ModelsRouteDetail
-- | ModelsRouteDetail
data ModelsRouteDetail = ModelsRouteDetail
  { modelsRouteDetailMethod :: !(Maybe Text) -- ^ "method"
  , modelsRouteDetailPath :: !(Maybe Text) -- ^ "path"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsRouteDetail
instance A.FromJSON ModelsRouteDetail where
  parseJSON = A.withObject "ModelsRouteDetail" $ \o ->
    ModelsRouteDetail
      <$> (o .:? "method")
      <*> (o .:? "path")

-- | ToJSON ModelsRouteDetail
instance A.ToJSON ModelsRouteDetail where
  toJSON ModelsRouteDetail {..} =
   _omitNulls
      [ "method" .= modelsRouteDetailMethod
      , "path" .= modelsRouteDetailPath
      ]


-- | Construct a value of type 'ModelsRouteDetail' (by applying it's required fields, if any)
mkModelsRouteDetail
  :: ModelsRouteDetail
mkModelsRouteDetail =
  ModelsRouteDetail
  { modelsRouteDetailMethod = Nothing
  , modelsRouteDetailPath = Nothing
  }

-- ** ModelsSavedFilter
-- | ModelsSavedFilter
data ModelsSavedFilter = ModelsSavedFilter
  { modelsSavedFilterCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this filter was created. You cannot change this value.
  , modelsSavedFilterDescription :: !(Maybe Text) -- ^ "description" - The description of the filter
  , modelsSavedFilterFilters :: !(Maybe ModelsTaskCollection) -- ^ "filters" - The actual filters this filter contains
  , modelsSavedFilterId :: !(Maybe Int) -- ^ "id" - The unique numeric id of this saved filter
  , modelsSavedFilterIsFavorite :: !(Maybe Bool) -- ^ "is_favorite" - True if the filter is a favorite. Favorite filters show up in a separate parent project together with favorite projects.
  , modelsSavedFilterOwner :: !(Maybe UserUser) -- ^ "owner" - The user who owns this filter
  , modelsSavedFilterTitle :: !(Maybe Text) -- ^ "title" - The title of the filter.
  , modelsSavedFilterUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this filter was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsSavedFilter
instance A.FromJSON ModelsSavedFilter where
  parseJSON = A.withObject "ModelsSavedFilter" $ \o ->
    ModelsSavedFilter
      <$> (o .:? "created")
      <*> (o .:? "description")
      <*> (o .:? "filters")
      <*> (o .:? "id")
      <*> (o .:? "is_favorite")
      <*> (o .:? "owner")
      <*> (o .:? "title")
      <*> (o .:? "updated")

-- | ToJSON ModelsSavedFilter
instance A.ToJSON ModelsSavedFilter where
  toJSON ModelsSavedFilter {..} =
   _omitNulls
      [ "created" .= modelsSavedFilterCreated
      , "description" .= modelsSavedFilterDescription
      , "filters" .= modelsSavedFilterFilters
      , "id" .= modelsSavedFilterId
      , "is_favorite" .= modelsSavedFilterIsFavorite
      , "owner" .= modelsSavedFilterOwner
      , "title" .= modelsSavedFilterTitle
      , "updated" .= modelsSavedFilterUpdated
      ]


-- | Construct a value of type 'ModelsSavedFilter' (by applying it's required fields, if any)
mkModelsSavedFilter
  :: ModelsSavedFilter
mkModelsSavedFilter =
  ModelsSavedFilter
  { modelsSavedFilterCreated = Nothing
  , modelsSavedFilterDescription = Nothing
  , modelsSavedFilterFilters = Nothing
  , modelsSavedFilterId = Nothing
  , modelsSavedFilterIsFavorite = Nothing
  , modelsSavedFilterOwner = Nothing
  , modelsSavedFilterTitle = Nothing
  , modelsSavedFilterUpdated = Nothing
  }

-- ** ModelsSubscription
-- | ModelsSubscription
data ModelsSubscription = ModelsSubscription
  { modelsSubscriptionCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this subscription was created. You cannot change this value.
  , modelsSubscriptionEntity :: !(Maybe Int) -- ^ "entity"
  , modelsSubscriptionEntityId :: !(Maybe Int) -- ^ "entity_id" - The id of the entity to subscribe to.
  , modelsSubscriptionId :: !(Maybe Int) -- ^ "id" - The numeric ID of the subscription
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsSubscription
instance A.FromJSON ModelsSubscription where
  parseJSON = A.withObject "ModelsSubscription" $ \o ->
    ModelsSubscription
      <$> (o .:? "created")
      <*> (o .:? "entity")
      <*> (o .:? "entity_id")
      <*> (o .:? "id")

-- | ToJSON ModelsSubscription
instance A.ToJSON ModelsSubscription where
  toJSON ModelsSubscription {..} =
   _omitNulls
      [ "created" .= modelsSubscriptionCreated
      , "entity" .= modelsSubscriptionEntity
      , "entity_id" .= modelsSubscriptionEntityId
      , "id" .= modelsSubscriptionId
      ]


-- | Construct a value of type 'ModelsSubscription' (by applying it's required fields, if any)
mkModelsSubscription
  :: ModelsSubscription
mkModelsSubscription =
  ModelsSubscription
  { modelsSubscriptionCreated = Nothing
  , modelsSubscriptionEntity = Nothing
  , modelsSubscriptionEntityId = Nothing
  , modelsSubscriptionId = Nothing
  }

-- ** ModelsTask
-- | ModelsTask
data ModelsTask = ModelsTask
  { modelsTaskAssignees :: !(Maybe [UserUser]) -- ^ "assignees" - An array of users who are assigned to this task
  , modelsTaskAttachments :: !(Maybe [ModelsTaskAttachment]) -- ^ "attachments" - All attachments this task has. This property is read-onlym, you must use the separate endpoint to add attachments to a task.
  , modelsTaskBucketId :: !(Maybe Int) -- ^ "bucket_id" - The bucket id. Will only be populated when the task is accessed via a view with buckets. Can be used to move a task between buckets. In that case, the new bucket must be in the same view as the old one.
  , modelsTaskCoverImageAttachmentId :: !(Maybe Int) -- ^ "cover_image_attachment_id" - If this task has a cover image, the field will return the id of the attachment that is the cover image.
  , modelsTaskCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this task was created. You cannot change this value.
  , modelsTaskCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who initially created the task.
  , modelsTaskDescription :: !(Maybe Text) -- ^ "description" - The task description.
  , modelsTaskDone :: !(Maybe Bool) -- ^ "done" - Whether a task is done or not.
  , modelsTaskDoneAt :: !(Maybe Text) -- ^ "done_at" - The time when a task was marked as done.
  , modelsTaskDueDate :: !(Maybe Text) -- ^ "due_date" - The time when the task is due.
  , modelsTaskEndDate :: !(Maybe Text) -- ^ "end_date" - When this task ends.
  , modelsTaskHexColor :: !(Maybe Text) -- ^ "hex_color" - The task color in hex
  , modelsTaskId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this task.
  , modelsTaskIdentifier :: !(Maybe Text) -- ^ "identifier" - The task identifier, based on the project identifier and the task&#39;s index
  , modelsTaskIndex :: !(Maybe Int) -- ^ "index" - The task index, calculated per project
  , modelsTaskIsFavorite :: !(Maybe Bool) -- ^ "is_favorite" - True if a task is a favorite task. Favorite tasks show up in a separate \&quot;Important\&quot; project. This value depends on the user making the call to the api.
  , modelsTaskLabels :: !(Maybe [ModelsLabel]) -- ^ "labels" - An array of labels which are associated with this task. This property is read-only, you must use the separate endpoint to add labels to a task.
  , modelsTaskPercentDone :: !(Maybe Double) -- ^ "percent_done" - Determines how far a task is left from being done
  , modelsTaskPosition :: !(Maybe Double) -- ^ "position" - The position of the task - any task project can be sorted as usual by this parameter. When accessing tasks via views with buckets, this is primarily used to sort them based on a range. Positions are always saved per view. They will automatically be set if you request the tasks through a view endpoint, otherwise they will always be 0. To update them, take a look at the Task Position endpoint.
  , modelsTaskPriority :: !(Maybe Int) -- ^ "priority" - The task priority. Can be anything you want, it is possible to sort by this later.
  , modelsTaskProjectId :: !(Maybe Int) -- ^ "project_id" - The project this task belongs to.
  , modelsTaskReactions :: !(Maybe (Map.Map String [UserUser])) -- ^ "reactions" - Reactions on that task.
  , modelsTaskRelatedTasks :: !(Maybe (Map.Map String [ModelsTask])) -- ^ "related_tasks" - All related tasks, grouped by their relation kind
  , modelsTaskReminders :: !(Maybe [ModelsTaskReminder]) -- ^ "reminders" - An array of reminders that are associated with this task.
  , modelsTaskRepeatAfter :: !(Maybe Int) -- ^ "repeat_after" - An amount in seconds this task repeats itself. If this is set, when marking the task as done, it will mark itself as \&quot;undone\&quot; and then increase all remindes and the due date by its amount.
  , modelsTaskRepeatMode :: !(Maybe ModelsTaskRepeatMode) -- ^ "repeat_mode" - Can have three possible values which will trigger when the task is marked as done: 0 &#x3D; repeats after the amount specified in repeat_after, 1 &#x3D; repeats all dates each months (ignoring repeat_after), 3 &#x3D; repeats from the current date rather than the last set date.
  , modelsTaskStartDate :: !(Maybe Text) -- ^ "start_date" - When this task starts.
  , modelsTaskSubscription :: !(Maybe ModelsSubscription) -- ^ "subscription" - The subscription status for the user reading this task. You can only read this property, use the subscription endpoints to modify it. Will only returned when retrieving one task.
  , modelsTaskTitle :: !(Maybe Text) -- ^ "title" - The task text. This is what you&#39;ll see in the project.
  , modelsTaskUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this task was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTask
instance A.FromJSON ModelsTask where
  parseJSON = A.withObject "ModelsTask" $ \o ->
    ModelsTask
      <$> (o .:? "assignees")
      <*> (o .:? "attachments")
      <*> (o .:? "bucket_id")
      <*> (o .:? "cover_image_attachment_id")
      <*> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "description")
      <*> (o .:? "done")
      <*> (o .:? "done_at")
      <*> (o .:? "due_date")
      <*> (o .:? "end_date")
      <*> (o .:? "hex_color")
      <*> (o .:? "id")
      <*> (o .:? "identifier")
      <*> (o .:? "index")
      <*> (o .:? "is_favorite")
      <*> (o .:? "labels")
      <*> (o .:? "percent_done")
      <*> (o .:? "position")
      <*> (o .:? "priority")
      <*> (o .:? "project_id")
      <*> (o .:? "reactions")
      <*> (o .:? "related_tasks")
      <*> (o .:? "reminders")
      <*> (o .:? "repeat_after")
      <*> (o .:? "repeat_mode")
      <*> (o .:? "start_date")
      <*> (o .:? "subscription")
      <*> (o .:? "title")
      <*> (o .:? "updated")

-- | ToJSON ModelsTask
instance A.ToJSON ModelsTask where
  toJSON ModelsTask {..} =
   _omitNulls
      [ "assignees" .= modelsTaskAssignees
      , "attachments" .= modelsTaskAttachments
      , "bucket_id" .= modelsTaskBucketId
      , "cover_image_attachment_id" .= modelsTaskCoverImageAttachmentId
      , "created" .= modelsTaskCreated
      , "created_by" .= modelsTaskCreatedBy
      , "description" .= modelsTaskDescription
      , "done" .= modelsTaskDone
      , "done_at" .= modelsTaskDoneAt
      , "due_date" .= modelsTaskDueDate
      , "end_date" .= modelsTaskEndDate
      , "hex_color" .= modelsTaskHexColor
      , "id" .= modelsTaskId
      , "identifier" .= modelsTaskIdentifier
      , "index" .= modelsTaskIndex
      , "is_favorite" .= modelsTaskIsFavorite
      , "labels" .= modelsTaskLabels
      , "percent_done" .= modelsTaskPercentDone
      , "position" .= modelsTaskPosition
      , "priority" .= modelsTaskPriority
      , "project_id" .= modelsTaskProjectId
      , "reactions" .= modelsTaskReactions
      , "related_tasks" .= modelsTaskRelatedTasks
      , "reminders" .= modelsTaskReminders
      , "repeat_after" .= modelsTaskRepeatAfter
      , "repeat_mode" .= modelsTaskRepeatMode
      , "start_date" .= modelsTaskStartDate
      , "subscription" .= modelsTaskSubscription
      , "title" .= modelsTaskTitle
      , "updated" .= modelsTaskUpdated
      ]


-- | Construct a value of type 'ModelsTask' (by applying it's required fields, if any)
mkModelsTask
  :: ModelsTask
mkModelsTask =
  ModelsTask
  { modelsTaskAssignees = Nothing
  , modelsTaskAttachments = Nothing
  , modelsTaskBucketId = Nothing
  , modelsTaskCoverImageAttachmentId = Nothing
  , modelsTaskCreated = Nothing
  , modelsTaskCreatedBy = Nothing
  , modelsTaskDescription = Nothing
  , modelsTaskDone = Nothing
  , modelsTaskDoneAt = Nothing
  , modelsTaskDueDate = Nothing
  , modelsTaskEndDate = Nothing
  , modelsTaskHexColor = Nothing
  , modelsTaskId = Nothing
  , modelsTaskIdentifier = Nothing
  , modelsTaskIndex = Nothing
  , modelsTaskIsFavorite = Nothing
  , modelsTaskLabels = Nothing
  , modelsTaskPercentDone = Nothing
  , modelsTaskPosition = Nothing
  , modelsTaskPriority = Nothing
  , modelsTaskProjectId = Nothing
  , modelsTaskReactions = Nothing
  , modelsTaskRelatedTasks = Nothing
  , modelsTaskReminders = Nothing
  , modelsTaskRepeatAfter = Nothing
  , modelsTaskRepeatMode = Nothing
  , modelsTaskStartDate = Nothing
  , modelsTaskSubscription = Nothing
  , modelsTaskTitle = Nothing
  , modelsTaskUpdated = Nothing
  }

-- ** ModelsTaskAssginee
-- | ModelsTaskAssginee
data ModelsTaskAssginee = ModelsTaskAssginee
  { modelsTaskAssgineeCreated :: !(Maybe Text) -- ^ "created"
  , modelsTaskAssgineeUserId :: !(Maybe Int) -- ^ "user_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskAssginee
instance A.FromJSON ModelsTaskAssginee where
  parseJSON = A.withObject "ModelsTaskAssginee" $ \o ->
    ModelsTaskAssginee
      <$> (o .:? "created")
      <*> (o .:? "user_id")

-- | ToJSON ModelsTaskAssginee
instance A.ToJSON ModelsTaskAssginee where
  toJSON ModelsTaskAssginee {..} =
   _omitNulls
      [ "created" .= modelsTaskAssgineeCreated
      , "user_id" .= modelsTaskAssgineeUserId
      ]


-- | Construct a value of type 'ModelsTaskAssginee' (by applying it's required fields, if any)
mkModelsTaskAssginee
  :: ModelsTaskAssginee
mkModelsTaskAssginee =
  ModelsTaskAssginee
  { modelsTaskAssgineeCreated = Nothing
  , modelsTaskAssgineeUserId = Nothing
  }

-- ** ModelsTaskAttachment
-- | ModelsTaskAttachment
data ModelsTaskAttachment = ModelsTaskAttachment
  { modelsTaskAttachmentCreated :: !(Maybe Text) -- ^ "created"
  , modelsTaskAttachmentCreatedBy :: !(Maybe UserUser) -- ^ "created_by"
  , modelsTaskAttachmentFile :: !(Maybe FilesFile) -- ^ "file"
  , modelsTaskAttachmentId :: !(Maybe Int) -- ^ "id"
  , modelsTaskAttachmentTaskId :: !(Maybe Int) -- ^ "task_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskAttachment
instance A.FromJSON ModelsTaskAttachment where
  parseJSON = A.withObject "ModelsTaskAttachment" $ \o ->
    ModelsTaskAttachment
      <$> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "file")
      <*> (o .:? "id")
      <*> (o .:? "task_id")

-- | ToJSON ModelsTaskAttachment
instance A.ToJSON ModelsTaskAttachment where
  toJSON ModelsTaskAttachment {..} =
   _omitNulls
      [ "created" .= modelsTaskAttachmentCreated
      , "created_by" .= modelsTaskAttachmentCreatedBy
      , "file" .= modelsTaskAttachmentFile
      , "id" .= modelsTaskAttachmentId
      , "task_id" .= modelsTaskAttachmentTaskId
      ]


-- | Construct a value of type 'ModelsTaskAttachment' (by applying it's required fields, if any)
mkModelsTaskAttachment
  :: ModelsTaskAttachment
mkModelsTaskAttachment =
  ModelsTaskAttachment
  { modelsTaskAttachmentCreated = Nothing
  , modelsTaskAttachmentCreatedBy = Nothing
  , modelsTaskAttachmentFile = Nothing
  , modelsTaskAttachmentId = Nothing
  , modelsTaskAttachmentTaskId = Nothing
  }

-- ** ModelsTaskBucket
-- | ModelsTaskBucket
data ModelsTaskBucket = ModelsTaskBucket
  { modelsTaskBucketBucketId :: !(Maybe Int) -- ^ "bucket_id"
  , modelsTaskBucketProjectViewId :: !(Maybe Int) -- ^ "project_view_id"
  , modelsTaskBucketTaskDone :: !(Maybe Bool) -- ^ "task_done"
  , modelsTaskBucketTaskId :: !(Maybe Int) -- ^ "task_id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskBucket
instance A.FromJSON ModelsTaskBucket where
  parseJSON = A.withObject "ModelsTaskBucket" $ \o ->
    ModelsTaskBucket
      <$> (o .:? "bucket_id")
      <*> (o .:? "project_view_id")
      <*> (o .:? "task_done")
      <*> (o .:? "task_id")

-- | ToJSON ModelsTaskBucket
instance A.ToJSON ModelsTaskBucket where
  toJSON ModelsTaskBucket {..} =
   _omitNulls
      [ "bucket_id" .= modelsTaskBucketBucketId
      , "project_view_id" .= modelsTaskBucketProjectViewId
      , "task_done" .= modelsTaskBucketTaskDone
      , "task_id" .= modelsTaskBucketTaskId
      ]


-- | Construct a value of type 'ModelsTaskBucket' (by applying it's required fields, if any)
mkModelsTaskBucket
  :: ModelsTaskBucket
mkModelsTaskBucket =
  ModelsTaskBucket
  { modelsTaskBucketBucketId = Nothing
  , modelsTaskBucketProjectViewId = Nothing
  , modelsTaskBucketTaskDone = Nothing
  , modelsTaskBucketTaskId = Nothing
  }

-- ** ModelsTaskCollection
-- | ModelsTaskCollection
data ModelsTaskCollection = ModelsTaskCollection
  { modelsTaskCollectionFilter :: !(Maybe Text) -- ^ "filter" - The filter query to match tasks by. Check out https://vikunja.io/docs/filters for a full explanation.
  , modelsTaskCollectionFilterIncludeNulls :: !(Maybe Bool) -- ^ "filter_include_nulls" - If set to true, the result will also include null values
  , modelsTaskCollectionOrderBy :: !(Maybe [Text]) -- ^ "order_by" - The query parameter to order the items by. This can be either asc or desc, with asc being the default.
  , modelsTaskCollectionSortBy :: !(Maybe [Text]) -- ^ "sort_by" - The query parameter to sort by. This is for ex. done, priority, etc.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskCollection
instance A.FromJSON ModelsTaskCollection where
  parseJSON = A.withObject "ModelsTaskCollection" $ \o ->
    ModelsTaskCollection
      <$> (o .:? "filter")
      <*> (o .:? "filter_include_nulls")
      <*> (o .:? "order_by")
      <*> (o .:? "sort_by")

-- | ToJSON ModelsTaskCollection
instance A.ToJSON ModelsTaskCollection where
  toJSON ModelsTaskCollection {..} =
   _omitNulls
      [ "filter" .= modelsTaskCollectionFilter
      , "filter_include_nulls" .= modelsTaskCollectionFilterIncludeNulls
      , "order_by" .= modelsTaskCollectionOrderBy
      , "sort_by" .= modelsTaskCollectionSortBy
      ]


-- | Construct a value of type 'ModelsTaskCollection' (by applying it's required fields, if any)
mkModelsTaskCollection
  :: ModelsTaskCollection
mkModelsTaskCollection =
  ModelsTaskCollection
  { modelsTaskCollectionFilter = Nothing
  , modelsTaskCollectionFilterIncludeNulls = Nothing
  , modelsTaskCollectionOrderBy = Nothing
  , modelsTaskCollectionSortBy = Nothing
  }

-- ** ModelsTaskComment
-- | ModelsTaskComment
data ModelsTaskComment = ModelsTaskComment
  { modelsTaskCommentAuthor :: !(Maybe UserUser) -- ^ "author"
  , modelsTaskCommentComment :: !(Maybe Text) -- ^ "comment"
  , modelsTaskCommentCreated :: !(Maybe Text) -- ^ "created"
  , modelsTaskCommentId :: !(Maybe Int) -- ^ "id"
  , modelsTaskCommentReactions :: !(Maybe (Map.Map String [UserUser])) -- ^ "reactions"
  , modelsTaskCommentUpdated :: !(Maybe Text) -- ^ "updated"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskComment
instance A.FromJSON ModelsTaskComment where
  parseJSON = A.withObject "ModelsTaskComment" $ \o ->
    ModelsTaskComment
      <$> (o .:? "author")
      <*> (o .:? "comment")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "reactions")
      <*> (o .:? "updated")

-- | ToJSON ModelsTaskComment
instance A.ToJSON ModelsTaskComment where
  toJSON ModelsTaskComment {..} =
   _omitNulls
      [ "author" .= modelsTaskCommentAuthor
      , "comment" .= modelsTaskCommentComment
      , "created" .= modelsTaskCommentCreated
      , "id" .= modelsTaskCommentId
      , "reactions" .= modelsTaskCommentReactions
      , "updated" .= modelsTaskCommentUpdated
      ]


-- | Construct a value of type 'ModelsTaskComment' (by applying it's required fields, if any)
mkModelsTaskComment
  :: ModelsTaskComment
mkModelsTaskComment =
  ModelsTaskComment
  { modelsTaskCommentAuthor = Nothing
  , modelsTaskCommentComment = Nothing
  , modelsTaskCommentCreated = Nothing
  , modelsTaskCommentId = Nothing
  , modelsTaskCommentReactions = Nothing
  , modelsTaskCommentUpdated = Nothing
  }

-- ** ModelsTaskPosition
-- | ModelsTaskPosition
data ModelsTaskPosition = ModelsTaskPosition
  { modelsTaskPositionPosition :: !(Maybe Double) -- ^ "position" - The position of the task - any task project can be sorted as usual by this parameter. When accessing tasks via kanban buckets, this is primarily used to sort them based on a range We&#39;re using a float64 here to make it possible to put any task within any two other tasks (by changing the number). You would calculate the new position between two tasks with something like task3.position &#x3D; (task2.position - task1.position) / 2. A 64-Bit float leaves plenty of room to initially give tasks a position with 2^16 difference to the previous task which also leaves a lot of room for rearranging and sorting later. Positions are always saved per view. They will automatically be set if you request the tasks through a view endpoint, otherwise they will always be 0. To update them, take a look at the Task Position endpoint.
  , modelsTaskPositionProjectViewId :: !(Maybe Int) -- ^ "project_view_id" - The project view this task is related to
  , modelsTaskPositionTaskId :: !(Maybe Int) -- ^ "task_id" - The ID of the task this position is for
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskPosition
instance A.FromJSON ModelsTaskPosition where
  parseJSON = A.withObject "ModelsTaskPosition" $ \o ->
    ModelsTaskPosition
      <$> (o .:? "position")
      <*> (o .:? "project_view_id")
      <*> (o .:? "task_id")

-- | ToJSON ModelsTaskPosition
instance A.ToJSON ModelsTaskPosition where
  toJSON ModelsTaskPosition {..} =
   _omitNulls
      [ "position" .= modelsTaskPositionPosition
      , "project_view_id" .= modelsTaskPositionProjectViewId
      , "task_id" .= modelsTaskPositionTaskId
      ]


-- | Construct a value of type 'ModelsTaskPosition' (by applying it's required fields, if any)
mkModelsTaskPosition
  :: ModelsTaskPosition
mkModelsTaskPosition =
  ModelsTaskPosition
  { modelsTaskPositionPosition = Nothing
  , modelsTaskPositionProjectViewId = Nothing
  , modelsTaskPositionTaskId = Nothing
  }

-- ** ModelsTaskRelation
-- | ModelsTaskRelation
data ModelsTaskRelation = ModelsTaskRelation
  { modelsTaskRelationCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this label was created. You cannot change this value.
  , modelsTaskRelationCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who created this relation
  , modelsTaskRelationOtherTaskId :: !(Maybe Int) -- ^ "other_task_id" - The ID of the other task, the task which is being related.
  , modelsTaskRelationRelationKind :: !(Maybe ModelsRelationKind) -- ^ "relation_kind" - The kind of the relation.
  , modelsTaskRelationTaskId :: !(Maybe Int) -- ^ "task_id" - The ID of the \&quot;base\&quot; task, the task which has a relation to another.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskRelation
instance A.FromJSON ModelsTaskRelation where
  parseJSON = A.withObject "ModelsTaskRelation" $ \o ->
    ModelsTaskRelation
      <$> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "other_task_id")
      <*> (o .:? "relation_kind")
      <*> (o .:? "task_id")

-- | ToJSON ModelsTaskRelation
instance A.ToJSON ModelsTaskRelation where
  toJSON ModelsTaskRelation {..} =
   _omitNulls
      [ "created" .= modelsTaskRelationCreated
      , "created_by" .= modelsTaskRelationCreatedBy
      , "other_task_id" .= modelsTaskRelationOtherTaskId
      , "relation_kind" .= modelsTaskRelationRelationKind
      , "task_id" .= modelsTaskRelationTaskId
      ]


-- | Construct a value of type 'ModelsTaskRelation' (by applying it's required fields, if any)
mkModelsTaskRelation
  :: ModelsTaskRelation
mkModelsTaskRelation =
  ModelsTaskRelation
  { modelsTaskRelationCreated = Nothing
  , modelsTaskRelationCreatedBy = Nothing
  , modelsTaskRelationOtherTaskId = Nothing
  , modelsTaskRelationRelationKind = Nothing
  , modelsTaskRelationTaskId = Nothing
  }

-- ** ModelsTaskReminder
-- | ModelsTaskReminder
data ModelsTaskReminder = ModelsTaskReminder
  { modelsTaskReminderRelativePeriod :: !(Maybe Int) -- ^ "relative_period" - A period in seconds relative to another date argument. Negative values mean the reminder triggers before the date. Default: 0, tiggers when RelativeTo is due.
  , modelsTaskReminderRelativeTo :: !(Maybe ModelsReminderRelation) -- ^ "relative_to" - The name of the date field to which the relative period refers to.
  , modelsTaskReminderReminder :: !(Maybe Text) -- ^ "reminder" - The absolute time when the user wants to be reminded of the task.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTaskReminder
instance A.FromJSON ModelsTaskReminder where
  parseJSON = A.withObject "ModelsTaskReminder" $ \o ->
    ModelsTaskReminder
      <$> (o .:? "relative_period")
      <*> (o .:? "relative_to")
      <*> (o .:? "reminder")

-- | ToJSON ModelsTaskReminder
instance A.ToJSON ModelsTaskReminder where
  toJSON ModelsTaskReminder {..} =
   _omitNulls
      [ "relative_period" .= modelsTaskReminderRelativePeriod
      , "relative_to" .= modelsTaskReminderRelativeTo
      , "reminder" .= modelsTaskReminderReminder
      ]


-- | Construct a value of type 'ModelsTaskReminder' (by applying it's required fields, if any)
mkModelsTaskReminder
  :: ModelsTaskReminder
mkModelsTaskReminder =
  ModelsTaskReminder
  { modelsTaskReminderRelativePeriod = Nothing
  , modelsTaskReminderRelativeTo = Nothing
  , modelsTaskReminderReminder = Nothing
  }

-- ** ModelsTeam
-- | ModelsTeam
data ModelsTeam = ModelsTeam
  { modelsTeamCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this relation was created. You cannot change this value.
  , modelsTeamCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who created this team.
  , modelsTeamDescription :: !(Maybe Text) -- ^ "description" - The team&#39;s description.
  , modelsTeamId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this team.
  , modelsTeamIncludePublic :: !(Maybe Bool) -- ^ "include_public" - Query parameter controlling whether to include public projects or not
  , modelsTeamIsPublic :: !(Maybe Bool) -- ^ "is_public" - Defines wether the team should be publicly discoverable when sharing a project
  , modelsTeamMembers :: !(Maybe [ModelsTeamUser]) -- ^ "members" - An array of all members in this team.
  , modelsTeamName :: !(Maybe Text) -- ^ "name" - The name of this team.
  , modelsTeamOidcId :: !(Maybe Text) -- ^ "oidc_id" - The team&#39;s oidc id delivered by the oidc provider
  , modelsTeamUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this relation was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTeam
instance A.FromJSON ModelsTeam where
  parseJSON = A.withObject "ModelsTeam" $ \o ->
    ModelsTeam
      <$> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "include_public")
      <*> (o .:? "is_public")
      <*> (o .:? "members")
      <*> (o .:? "name")
      <*> (o .:? "oidc_id")
      <*> (o .:? "updated")

-- | ToJSON ModelsTeam
instance A.ToJSON ModelsTeam where
  toJSON ModelsTeam {..} =
   _omitNulls
      [ "created" .= modelsTeamCreated
      , "created_by" .= modelsTeamCreatedBy
      , "description" .= modelsTeamDescription
      , "id" .= modelsTeamId
      , "include_public" .= modelsTeamIncludePublic
      , "is_public" .= modelsTeamIsPublic
      , "members" .= modelsTeamMembers
      , "name" .= modelsTeamName
      , "oidc_id" .= modelsTeamOidcId
      , "updated" .= modelsTeamUpdated
      ]


-- | Construct a value of type 'ModelsTeam' (by applying it's required fields, if any)
mkModelsTeam
  :: ModelsTeam
mkModelsTeam =
  ModelsTeam
  { modelsTeamCreated = Nothing
  , modelsTeamCreatedBy = Nothing
  , modelsTeamDescription = Nothing
  , modelsTeamId = Nothing
  , modelsTeamIncludePublic = Nothing
  , modelsTeamIsPublic = Nothing
  , modelsTeamMembers = Nothing
  , modelsTeamName = Nothing
  , modelsTeamOidcId = Nothing
  , modelsTeamUpdated = Nothing
  }

-- ** ModelsTeamMember
-- | ModelsTeamMember
data ModelsTeamMember = ModelsTeamMember
  { modelsTeamMemberAdmin :: !(Maybe Bool) -- ^ "admin" - Whether or not the member is an admin of the team. See the docs for more about what a team admin can do
  , modelsTeamMemberCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this relation was created. You cannot change this value.
  , modelsTeamMemberId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this team member relation.
  , modelsTeamMemberUsername :: !(Maybe Text) -- ^ "username" - The username of the member. We use this to prevent automated user id entering.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTeamMember
instance A.FromJSON ModelsTeamMember where
  parseJSON = A.withObject "ModelsTeamMember" $ \o ->
    ModelsTeamMember
      <$> (o .:? "admin")
      <*> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "username")

-- | ToJSON ModelsTeamMember
instance A.ToJSON ModelsTeamMember where
  toJSON ModelsTeamMember {..} =
   _omitNulls
      [ "admin" .= modelsTeamMemberAdmin
      , "created" .= modelsTeamMemberCreated
      , "id" .= modelsTeamMemberId
      , "username" .= modelsTeamMemberUsername
      ]


-- | Construct a value of type 'ModelsTeamMember' (by applying it's required fields, if any)
mkModelsTeamMember
  :: ModelsTeamMember
mkModelsTeamMember =
  ModelsTeamMember
  { modelsTeamMemberAdmin = Nothing
  , modelsTeamMemberCreated = Nothing
  , modelsTeamMemberId = Nothing
  , modelsTeamMemberUsername = Nothing
  }

-- ** ModelsTeamProject
-- | ModelsTeamProject
data ModelsTeamProject = ModelsTeamProject
  { modelsTeamProjectCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this relation was created. You cannot change this value.
  , modelsTeamProjectId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this project &lt;-&gt; team relation.
  , modelsTeamProjectRight :: !(Maybe ModelsRight) -- ^ "right" - The right this team has. 0 &#x3D; Read only, 1 &#x3D; Read &amp; Write, 2 &#x3D; Admin. See the docs for more details.
  , modelsTeamProjectTeamId :: !(Maybe Int) -- ^ "team_id" - The team id.
  , modelsTeamProjectUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this relation was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTeamProject
instance A.FromJSON ModelsTeamProject where
  parseJSON = A.withObject "ModelsTeamProject" $ \o ->
    ModelsTeamProject
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "right")
      <*> (o .:? "team_id")
      <*> (o .:? "updated")

-- | ToJSON ModelsTeamProject
instance A.ToJSON ModelsTeamProject where
  toJSON ModelsTeamProject {..} =
   _omitNulls
      [ "created" .= modelsTeamProjectCreated
      , "id" .= modelsTeamProjectId
      , "right" .= modelsTeamProjectRight
      , "team_id" .= modelsTeamProjectTeamId
      , "updated" .= modelsTeamProjectUpdated
      ]


-- | Construct a value of type 'ModelsTeamProject' (by applying it's required fields, if any)
mkModelsTeamProject
  :: ModelsTeamProject
mkModelsTeamProject =
  ModelsTeamProject
  { modelsTeamProjectCreated = Nothing
  , modelsTeamProjectId = Nothing
  , modelsTeamProjectRight = Nothing
  , modelsTeamProjectTeamId = Nothing
  , modelsTeamProjectUpdated = Nothing
  }

-- ** ModelsTeamUser
-- | ModelsTeamUser
data ModelsTeamUser = ModelsTeamUser
  { modelsTeamUserAdmin :: !(Maybe Bool) -- ^ "admin" - Whether the member is an admin of the team. See the docs for more about what a team admin can do
  , modelsTeamUserCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this task was created. You cannot change this value.
  , modelsTeamUserEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address.
  , modelsTeamUserId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this user.
  , modelsTeamUserName :: !(Maybe Text) -- ^ "name" - The full name of the user.
  , modelsTeamUserUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this task was last updated. You cannot change this value.
  , modelsTeamUserUsername :: !(Maybe Text) -- ^ "username" - The username of the user. Is always unique.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTeamUser
instance A.FromJSON ModelsTeamUser where
  parseJSON = A.withObject "ModelsTeamUser" $ \o ->
    ModelsTeamUser
      <$> (o .:? "admin")
      <*> (o .:? "created")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "updated")
      <*> (o .:? "username")

-- | ToJSON ModelsTeamUser
instance A.ToJSON ModelsTeamUser where
  toJSON ModelsTeamUser {..} =
   _omitNulls
      [ "admin" .= modelsTeamUserAdmin
      , "created" .= modelsTeamUserCreated
      , "email" .= modelsTeamUserEmail
      , "id" .= modelsTeamUserId
      , "name" .= modelsTeamUserName
      , "updated" .= modelsTeamUserUpdated
      , "username" .= modelsTeamUserUsername
      ]


-- | Construct a value of type 'ModelsTeamUser' (by applying it's required fields, if any)
mkModelsTeamUser
  :: ModelsTeamUser
mkModelsTeamUser =
  ModelsTeamUser
  { modelsTeamUserAdmin = Nothing
  , modelsTeamUserCreated = Nothing
  , modelsTeamUserEmail = Nothing
  , modelsTeamUserId = Nothing
  , modelsTeamUserName = Nothing
  , modelsTeamUserUpdated = Nothing
  , modelsTeamUserUsername = Nothing
  }

-- ** ModelsTeamWithRight
-- | ModelsTeamWithRight
data ModelsTeamWithRight = ModelsTeamWithRight
  { modelsTeamWithRightCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this relation was created. You cannot change this value.
  , modelsTeamWithRightCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who created this team.
  , modelsTeamWithRightDescription :: !(Maybe Text) -- ^ "description" - The team&#39;s description.
  , modelsTeamWithRightId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this team.
  , modelsTeamWithRightIncludePublic :: !(Maybe Bool) -- ^ "include_public" - Query parameter controlling whether to include public projects or not
  , modelsTeamWithRightIsPublic :: !(Maybe Bool) -- ^ "is_public" - Defines wether the team should be publicly discoverable when sharing a project
  , modelsTeamWithRightMembers :: !(Maybe [ModelsTeamUser]) -- ^ "members" - An array of all members in this team.
  , modelsTeamWithRightName :: !(Maybe Text) -- ^ "name" - The name of this team.
  , modelsTeamWithRightOidcId :: !(Maybe Text) -- ^ "oidc_id" - The team&#39;s oidc id delivered by the oidc provider
  , modelsTeamWithRightRight :: !(Maybe ModelsRight) -- ^ "right"
  , modelsTeamWithRightUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this relation was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsTeamWithRight
instance A.FromJSON ModelsTeamWithRight where
  parseJSON = A.withObject "ModelsTeamWithRight" $ \o ->
    ModelsTeamWithRight
      <$> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "include_public")
      <*> (o .:? "is_public")
      <*> (o .:? "members")
      <*> (o .:? "name")
      <*> (o .:? "oidc_id")
      <*> (o .:? "right")
      <*> (o .:? "updated")

-- | ToJSON ModelsTeamWithRight
instance A.ToJSON ModelsTeamWithRight where
  toJSON ModelsTeamWithRight {..} =
   _omitNulls
      [ "created" .= modelsTeamWithRightCreated
      , "created_by" .= modelsTeamWithRightCreatedBy
      , "description" .= modelsTeamWithRightDescription
      , "id" .= modelsTeamWithRightId
      , "include_public" .= modelsTeamWithRightIncludePublic
      , "is_public" .= modelsTeamWithRightIsPublic
      , "members" .= modelsTeamWithRightMembers
      , "name" .= modelsTeamWithRightName
      , "oidc_id" .= modelsTeamWithRightOidcId
      , "right" .= modelsTeamWithRightRight
      , "updated" .= modelsTeamWithRightUpdated
      ]


-- | Construct a value of type 'ModelsTeamWithRight' (by applying it's required fields, if any)
mkModelsTeamWithRight
  :: ModelsTeamWithRight
mkModelsTeamWithRight =
  ModelsTeamWithRight
  { modelsTeamWithRightCreated = Nothing
  , modelsTeamWithRightCreatedBy = Nothing
  , modelsTeamWithRightDescription = Nothing
  , modelsTeamWithRightId = Nothing
  , modelsTeamWithRightIncludePublic = Nothing
  , modelsTeamWithRightIsPublic = Nothing
  , modelsTeamWithRightMembers = Nothing
  , modelsTeamWithRightName = Nothing
  , modelsTeamWithRightOidcId = Nothing
  , modelsTeamWithRightRight = Nothing
  , modelsTeamWithRightUpdated = Nothing
  }

-- ** ModelsUserWithRight
-- | ModelsUserWithRight
data ModelsUserWithRight = ModelsUserWithRight
  { modelsUserWithRightCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this task was created. You cannot change this value.
  , modelsUserWithRightEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address.
  , modelsUserWithRightId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this user.
  , modelsUserWithRightName :: !(Maybe Text) -- ^ "name" - The full name of the user.
  , modelsUserWithRightRight :: !(Maybe ModelsRight) -- ^ "right"
  , modelsUserWithRightUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this task was last updated. You cannot change this value.
  , modelsUserWithRightUsername :: !(Maybe Text) -- ^ "username" - The username of the user. Is always unique.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsUserWithRight
instance A.FromJSON ModelsUserWithRight where
  parseJSON = A.withObject "ModelsUserWithRight" $ \o ->
    ModelsUserWithRight
      <$> (o .:? "created")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "right")
      <*> (o .:? "updated")
      <*> (o .:? "username")

-- | ToJSON ModelsUserWithRight
instance A.ToJSON ModelsUserWithRight where
  toJSON ModelsUserWithRight {..} =
   _omitNulls
      [ "created" .= modelsUserWithRightCreated
      , "email" .= modelsUserWithRightEmail
      , "id" .= modelsUserWithRightId
      , "name" .= modelsUserWithRightName
      , "right" .= modelsUserWithRightRight
      , "updated" .= modelsUserWithRightUpdated
      , "username" .= modelsUserWithRightUsername
      ]


-- | Construct a value of type 'ModelsUserWithRight' (by applying it's required fields, if any)
mkModelsUserWithRight
  :: ModelsUserWithRight
mkModelsUserWithRight =
  ModelsUserWithRight
  { modelsUserWithRightCreated = Nothing
  , modelsUserWithRightEmail = Nothing
  , modelsUserWithRightId = Nothing
  , modelsUserWithRightName = Nothing
  , modelsUserWithRightRight = Nothing
  , modelsUserWithRightUpdated = Nothing
  , modelsUserWithRightUsername = Nothing
  }

-- ** ModelsWebhook
-- | ModelsWebhook
data ModelsWebhook = ModelsWebhook
  { modelsWebhookCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this webhook target was created. You cannot change this value.
  , modelsWebhookCreatedBy :: !(Maybe UserUser) -- ^ "created_by" - The user who initially created the webhook target.
  , modelsWebhookEvents :: !(Maybe [Text]) -- ^ "events" - The webhook events which should fire this webhook target
  , modelsWebhookId :: !(Maybe Int) -- ^ "id" - The generated ID of this webhook target
  , modelsWebhookProjectId :: !(Maybe Int) -- ^ "project_id" - The project ID of the project this webhook target belongs to
  , modelsWebhookSecret :: !(Maybe Text) -- ^ "secret" - If provided, webhook requests will be signed using HMAC. Check out the docs about how to use this: https://vikunja.io/docs/webhooks/#signing
  , modelsWebhookTargetUrl :: !(Maybe Text) -- ^ "target_url" - The target URL where the POST request with the webhook payload will be made
  , modelsWebhookUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this webhook target was last updated. You cannot change this value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsWebhook
instance A.FromJSON ModelsWebhook where
  parseJSON = A.withObject "ModelsWebhook" $ \o ->
    ModelsWebhook
      <$> (o .:? "created")
      <*> (o .:? "created_by")
      <*> (o .:? "events")
      <*> (o .:? "id")
      <*> (o .:? "project_id")
      <*> (o .:? "secret")
      <*> (o .:? "target_url")
      <*> (o .:? "updated")

-- | ToJSON ModelsWebhook
instance A.ToJSON ModelsWebhook where
  toJSON ModelsWebhook {..} =
   _omitNulls
      [ "created" .= modelsWebhookCreated
      , "created_by" .= modelsWebhookCreatedBy
      , "events" .= modelsWebhookEvents
      , "id" .= modelsWebhookId
      , "project_id" .= modelsWebhookProjectId
      , "secret" .= modelsWebhookSecret
      , "target_url" .= modelsWebhookTargetUrl
      , "updated" .= modelsWebhookUpdated
      ]


-- | Construct a value of type 'ModelsWebhook' (by applying it's required fields, if any)
mkModelsWebhook
  :: ModelsWebhook
mkModelsWebhook =
  ModelsWebhook
  { modelsWebhookCreated = Nothing
  , modelsWebhookCreatedBy = Nothing
  , modelsWebhookEvents = Nothing
  , modelsWebhookId = Nothing
  , modelsWebhookProjectId = Nothing
  , modelsWebhookSecret = Nothing
  , modelsWebhookTargetUrl = Nothing
  , modelsWebhookUpdated = Nothing
  }

-- ** NotificationsDatabaseNotification
-- | NotificationsDatabaseNotification
data NotificationsDatabaseNotification = NotificationsDatabaseNotification
  { notificationsDatabaseNotificationCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this notification was created. You cannot change this value.
  , notificationsDatabaseNotificationId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this notification.
  , notificationsDatabaseNotificationName :: !(Maybe Text) -- ^ "name" - The name of the notification
  , notificationsDatabaseNotificationNotification :: !(Maybe A.Value) -- ^ "notification" - The actual content of the notification.
  , notificationsDatabaseNotificationReadAt :: !(Maybe Text) -- ^ "read_at" - When this notification is marked as read, this will be updated with the current timestamp.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NotificationsDatabaseNotification
instance A.FromJSON NotificationsDatabaseNotification where
  parseJSON = A.withObject "NotificationsDatabaseNotification" $ \o ->
    NotificationsDatabaseNotification
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "notification")
      <*> (o .:? "read_at")

-- | ToJSON NotificationsDatabaseNotification
instance A.ToJSON NotificationsDatabaseNotification where
  toJSON NotificationsDatabaseNotification {..} =
   _omitNulls
      [ "created" .= notificationsDatabaseNotificationCreated
      , "id" .= notificationsDatabaseNotificationId
      , "name" .= notificationsDatabaseNotificationName
      , "notification" .= notificationsDatabaseNotificationNotification
      , "read_at" .= notificationsDatabaseNotificationReadAt
      ]


-- | Construct a value of type 'NotificationsDatabaseNotification' (by applying it's required fields, if any)
mkNotificationsDatabaseNotification
  :: NotificationsDatabaseNotification
mkNotificationsDatabaseNotification =
  NotificationsDatabaseNotification
  { notificationsDatabaseNotificationCreated = Nothing
  , notificationsDatabaseNotificationId = Nothing
  , notificationsDatabaseNotificationName = Nothing
  , notificationsDatabaseNotificationNotification = Nothing
  , notificationsDatabaseNotificationReadAt = Nothing
  }

-- ** OpenidCallback
-- | OpenidCallback
data OpenidCallback = OpenidCallback
  { openidCallbackCode :: !(Maybe Text) -- ^ "code"
  , openidCallbackRedirectUrl :: !(Maybe Text) -- ^ "redirect_url"
  , openidCallbackScope :: !(Maybe Text) -- ^ "scope"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenidCallback
instance A.FromJSON OpenidCallback where
  parseJSON = A.withObject "OpenidCallback" $ \o ->
    OpenidCallback
      <$> (o .:? "code")
      <*> (o .:? "redirect_url")
      <*> (o .:? "scope")

-- | ToJSON OpenidCallback
instance A.ToJSON OpenidCallback where
  toJSON OpenidCallback {..} =
   _omitNulls
      [ "code" .= openidCallbackCode
      , "redirect_url" .= openidCallbackRedirectUrl
      , "scope" .= openidCallbackScope
      ]


-- | Construct a value of type 'OpenidCallback' (by applying it's required fields, if any)
mkOpenidCallback
  :: OpenidCallback
mkOpenidCallback =
  OpenidCallback
  { openidCallbackCode = Nothing
  , openidCallbackRedirectUrl = Nothing
  , openidCallbackScope = Nothing
  }

-- ** OpenidProvider
-- | OpenidProvider
data OpenidProvider = OpenidProvider
  { openidProviderAuthUrl :: !(Maybe Text) -- ^ "auth_url"
  , openidProviderClientId :: !(Maybe Text) -- ^ "client_id"
  , openidProviderKey :: !(Maybe Text) -- ^ "key"
  , openidProviderLogoutUrl :: !(Maybe Text) -- ^ "logout_url"
  , openidProviderName :: !(Maybe Text) -- ^ "name"
  , openidProviderScope :: !(Maybe Text) -- ^ "scope"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenidProvider
instance A.FromJSON OpenidProvider where
  parseJSON = A.withObject "OpenidProvider" $ \o ->
    OpenidProvider
      <$> (o .:? "auth_url")
      <*> (o .:? "client_id")
      <*> (o .:? "key")
      <*> (o .:? "logout_url")
      <*> (o .:? "name")
      <*> (o .:? "scope")

-- | ToJSON OpenidProvider
instance A.ToJSON OpenidProvider where
  toJSON OpenidProvider {..} =
   _omitNulls
      [ "auth_url" .= openidProviderAuthUrl
      , "client_id" .= openidProviderClientId
      , "key" .= openidProviderKey
      , "logout_url" .= openidProviderLogoutUrl
      , "name" .= openidProviderName
      , "scope" .= openidProviderScope
      ]


-- | Construct a value of type 'OpenidProvider' (by applying it's required fields, if any)
mkOpenidProvider
  :: OpenidProvider
mkOpenidProvider =
  OpenidProvider
  { openidProviderAuthUrl = Nothing
  , openidProviderClientId = Nothing
  , openidProviderKey = Nothing
  , openidProviderLogoutUrl = Nothing
  , openidProviderName = Nothing
  , openidProviderScope = Nothing
  }

-- ** TodoistMigration
-- | TodoistMigration
data TodoistMigration = TodoistMigration
  { todoistMigrationCode :: !(Maybe Text) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TodoistMigration
instance A.FromJSON TodoistMigration where
  parseJSON = A.withObject "TodoistMigration" $ \o ->
    TodoistMigration
      <$> (o .:? "code")

-- | ToJSON TodoistMigration
instance A.ToJSON TodoistMigration where
  toJSON TodoistMigration {..} =
   _omitNulls
      [ "code" .= todoistMigrationCode
      ]


-- | Construct a value of type 'TodoistMigration' (by applying it's required fields, if any)
mkTodoistMigration
  :: TodoistMigration
mkTodoistMigration =
  TodoistMigration
  { todoistMigrationCode = Nothing
  }

-- ** TrelloMigration
-- | TrelloMigration
data TrelloMigration = TrelloMigration
  { trelloMigrationCode :: !(Maybe Text) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TrelloMigration
instance A.FromJSON TrelloMigration where
  parseJSON = A.withObject "TrelloMigration" $ \o ->
    TrelloMigration
      <$> (o .:? "code")

-- | ToJSON TrelloMigration
instance A.ToJSON TrelloMigration where
  toJSON TrelloMigration {..} =
   _omitNulls
      [ "code" .= trelloMigrationCode
      ]


-- | Construct a value of type 'TrelloMigration' (by applying it's required fields, if any)
mkTrelloMigration
  :: TrelloMigration
mkTrelloMigration =
  TrelloMigration
  { trelloMigrationCode = Nothing
  }

-- ** UserAPIUserPassword
-- | UserAPIUserPassword
data UserAPIUserPassword = UserAPIUserPassword
  { userAPIUserPasswordEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address
  , userAPIUserPasswordId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this user.
  , userAPIUserPasswordPassword :: !(Maybe Text) -- ^ "password" - The user&#39;s password in clear text. Only used when registering the user. The maximum limi is 72 bytes, which may be less than 72 characters. This is due to the limit in the bcrypt hashing algorithm used to store passwords in Vikunja.
  , userAPIUserPasswordUsername :: !(Maybe Text) -- ^ "username" - The user&#39;s username. Cannot contain anything that looks like an url or whitespaces.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserAPIUserPassword
instance A.FromJSON UserAPIUserPassword where
  parseJSON = A.withObject "UserAPIUserPassword" $ \o ->
    UserAPIUserPassword
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "password")
      <*> (o .:? "username")

-- | ToJSON UserAPIUserPassword
instance A.ToJSON UserAPIUserPassword where
  toJSON UserAPIUserPassword {..} =
   _omitNulls
      [ "email" .= userAPIUserPasswordEmail
      , "id" .= userAPIUserPasswordId
      , "password" .= userAPIUserPasswordPassword
      , "username" .= userAPIUserPasswordUsername
      ]


-- | Construct a value of type 'UserAPIUserPassword' (by applying it's required fields, if any)
mkUserAPIUserPassword
  :: UserAPIUserPassword
mkUserAPIUserPassword =
  UserAPIUserPassword
  { userAPIUserPasswordEmail = Nothing
  , userAPIUserPasswordId = Nothing
  , userAPIUserPasswordPassword = Nothing
  , userAPIUserPasswordUsername = Nothing
  }

-- ** UserEmailConfirm
-- | UserEmailConfirm
data UserEmailConfirm = UserEmailConfirm
  { userEmailConfirmToken :: !(Maybe Text) -- ^ "token" - The email confirm token sent via email.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserEmailConfirm
instance A.FromJSON UserEmailConfirm where
  parseJSON = A.withObject "UserEmailConfirm" $ \o ->
    UserEmailConfirm
      <$> (o .:? "token")

-- | ToJSON UserEmailConfirm
instance A.ToJSON UserEmailConfirm where
  toJSON UserEmailConfirm {..} =
   _omitNulls
      [ "token" .= userEmailConfirmToken
      ]


-- | Construct a value of type 'UserEmailConfirm' (by applying it's required fields, if any)
mkUserEmailConfirm
  :: UserEmailConfirm
mkUserEmailConfirm =
  UserEmailConfirm
  { userEmailConfirmToken = Nothing
  }

-- ** UserEmailUpdate
-- | UserEmailUpdate
data UserEmailUpdate = UserEmailUpdate
  { userEmailUpdateNewEmail :: !(Maybe Text) -- ^ "new_email" - The new email address. Needs to be a valid email address.
  , userEmailUpdatePassword :: !(Maybe Text) -- ^ "password" - The password of the user for confirmation.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserEmailUpdate
instance A.FromJSON UserEmailUpdate where
  parseJSON = A.withObject "UserEmailUpdate" $ \o ->
    UserEmailUpdate
      <$> (o .:? "new_email")
      <*> (o .:? "password")

-- | ToJSON UserEmailUpdate
instance A.ToJSON UserEmailUpdate where
  toJSON UserEmailUpdate {..} =
   _omitNulls
      [ "new_email" .= userEmailUpdateNewEmail
      , "password" .= userEmailUpdatePassword
      ]


-- | Construct a value of type 'UserEmailUpdate' (by applying it's required fields, if any)
mkUserEmailUpdate
  :: UserEmailUpdate
mkUserEmailUpdate =
  UserEmailUpdate
  { userEmailUpdateNewEmail = Nothing
  , userEmailUpdatePassword = Nothing
  }

-- ** UserLogin
-- | UserLogin
data UserLogin = UserLogin
  { userLoginLongToken :: !(Maybe Bool) -- ^ "long_token" - If true, the token returned will be valid a lot longer than default. Useful for \&quot;remember me\&quot; style logins.
  , userLoginPassword :: !(Maybe Text) -- ^ "password" - The password for the user.
  , userLoginTotpPasscode :: !(Maybe Text) -- ^ "totp_passcode" - The totp passcode of a user. Only needs to be provided when enabled.
  , userLoginUsername :: !(Maybe Text) -- ^ "username" - The username used to log in.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserLogin
instance A.FromJSON UserLogin where
  parseJSON = A.withObject "UserLogin" $ \o ->
    UserLogin
      <$> (o .:? "long_token")
      <*> (o .:? "password")
      <*> (o .:? "totp_passcode")
      <*> (o .:? "username")

-- | ToJSON UserLogin
instance A.ToJSON UserLogin where
  toJSON UserLogin {..} =
   _omitNulls
      [ "long_token" .= userLoginLongToken
      , "password" .= userLoginPassword
      , "totp_passcode" .= userLoginTotpPasscode
      , "username" .= userLoginUsername
      ]


-- | Construct a value of type 'UserLogin' (by applying it's required fields, if any)
mkUserLogin
  :: UserLogin
mkUserLogin =
  UserLogin
  { userLoginLongToken = Nothing
  , userLoginPassword = Nothing
  , userLoginTotpPasscode = Nothing
  , userLoginUsername = Nothing
  }

-- ** UserPasswordReset
-- | UserPasswordReset
data UserPasswordReset = UserPasswordReset
  { userPasswordResetNewPassword :: !(Maybe Text) -- ^ "new_password" - The new password for this user.
  , userPasswordResetToken :: !(Maybe Text) -- ^ "token" - The previously issued reset token.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserPasswordReset
instance A.FromJSON UserPasswordReset where
  parseJSON = A.withObject "UserPasswordReset" $ \o ->
    UserPasswordReset
      <$> (o .:? "new_password")
      <*> (o .:? "token")

-- | ToJSON UserPasswordReset
instance A.ToJSON UserPasswordReset where
  toJSON UserPasswordReset {..} =
   _omitNulls
      [ "new_password" .= userPasswordResetNewPassword
      , "token" .= userPasswordResetToken
      ]


-- | Construct a value of type 'UserPasswordReset' (by applying it's required fields, if any)
mkUserPasswordReset
  :: UserPasswordReset
mkUserPasswordReset =
  UserPasswordReset
  { userPasswordResetNewPassword = Nothing
  , userPasswordResetToken = Nothing
  }

-- ** UserPasswordTokenRequest
-- | UserPasswordTokenRequest
data UserPasswordTokenRequest = UserPasswordTokenRequest
  { userPasswordTokenRequestEmail :: !(Maybe Text) -- ^ "email"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserPasswordTokenRequest
instance A.FromJSON UserPasswordTokenRequest where
  parseJSON = A.withObject "UserPasswordTokenRequest" $ \o ->
    UserPasswordTokenRequest
      <$> (o .:? "email")

-- | ToJSON UserPasswordTokenRequest
instance A.ToJSON UserPasswordTokenRequest where
  toJSON UserPasswordTokenRequest {..} =
   _omitNulls
      [ "email" .= userPasswordTokenRequestEmail
      ]


-- | Construct a value of type 'UserPasswordTokenRequest' (by applying it's required fields, if any)
mkUserPasswordTokenRequest
  :: UserPasswordTokenRequest
mkUserPasswordTokenRequest =
  UserPasswordTokenRequest
  { userPasswordTokenRequestEmail = Nothing
  }

-- ** UserTOTP
-- | UserTOTP
data UserTOTP = UserTOTP
  { userTOTPEnabled :: !(Maybe Bool) -- ^ "enabled" - The totp entry will only be enabled after the user verified they have a working totp setup.
  , userTOTPSecret :: !(Maybe Text) -- ^ "secret"
  , userTOTPUrl :: !(Maybe Text) -- ^ "url" - The totp url used to be able to enroll the user later
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTOTP
instance A.FromJSON UserTOTP where
  parseJSON = A.withObject "UserTOTP" $ \o ->
    UserTOTP
      <$> (o .:? "enabled")
      <*> (o .:? "secret")
      <*> (o .:? "url")

-- | ToJSON UserTOTP
instance A.ToJSON UserTOTP where
  toJSON UserTOTP {..} =
   _omitNulls
      [ "enabled" .= userTOTPEnabled
      , "secret" .= userTOTPSecret
      , "url" .= userTOTPUrl
      ]


-- | Construct a value of type 'UserTOTP' (by applying it's required fields, if any)
mkUserTOTP
  :: UserTOTP
mkUserTOTP =
  UserTOTP
  { userTOTPEnabled = Nothing
  , userTOTPSecret = Nothing
  , userTOTPUrl = Nothing
  }

-- ** UserTOTPPasscode
-- | UserTOTPPasscode
data UserTOTPPasscode = UserTOTPPasscode
  { userTOTPPasscodePasscode :: !(Maybe Text) -- ^ "passcode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserTOTPPasscode
instance A.FromJSON UserTOTPPasscode where
  parseJSON = A.withObject "UserTOTPPasscode" $ \o ->
    UserTOTPPasscode
      <$> (o .:? "passcode")

-- | ToJSON UserTOTPPasscode
instance A.ToJSON UserTOTPPasscode where
  toJSON UserTOTPPasscode {..} =
   _omitNulls
      [ "passcode" .= userTOTPPasscodePasscode
      ]


-- | Construct a value of type 'UserTOTPPasscode' (by applying it's required fields, if any)
mkUserTOTPPasscode
  :: UserTOTPPasscode
mkUserTOTPPasscode =
  UserTOTPPasscode
  { userTOTPPasscodePasscode = Nothing
  }

-- ** UserToken
-- | UserToken
data UserToken = UserToken
  { userTokenCreated :: !(Maybe Text) -- ^ "created"
  , userTokenId :: !(Maybe Int) -- ^ "id"
  , userTokenToken :: !(Maybe Text) -- ^ "token"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserToken
instance A.FromJSON UserToken where
  parseJSON = A.withObject "UserToken" $ \o ->
    UserToken
      <$> (o .:? "created")
      <*> (o .:? "id")
      <*> (o .:? "token")

-- | ToJSON UserToken
instance A.ToJSON UserToken where
  toJSON UserToken {..} =
   _omitNulls
      [ "created" .= userTokenCreated
      , "id" .= userTokenId
      , "token" .= userTokenToken
      ]


-- | Construct a value of type 'UserToken' (by applying it's required fields, if any)
mkUserToken
  :: UserToken
mkUserToken =
  UserToken
  { userTokenCreated = Nothing
  , userTokenId = Nothing
  , userTokenToken = Nothing
  }

-- ** UserUser
-- | UserUser
data UserUser = UserUser
  { userUserCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this task was created. You cannot change this value.
  , userUserEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address.
  , userUserId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this user.
  , userUserName :: !(Maybe Text) -- ^ "name" - The full name of the user.
  , userUserUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this task was last updated. You cannot change this value.
  , userUserUsername :: !(Maybe Text) -- ^ "username" - The username of the user. Is always unique.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserUser
instance A.FromJSON UserUser where
  parseJSON = A.withObject "UserUser" $ \o ->
    UserUser
      <$> (o .:? "created")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "updated")
      <*> (o .:? "username")

-- | ToJSON UserUser
instance A.ToJSON UserUser where
  toJSON UserUser {..} =
   _omitNulls
      [ "created" .= userUserCreated
      , "email" .= userUserEmail
      , "id" .= userUserId
      , "name" .= userUserName
      , "updated" .= userUserUpdated
      , "username" .= userUserUsername
      ]


-- | Construct a value of type 'UserUser' (by applying it's required fields, if any)
mkUserUser
  :: UserUser
mkUserUser =
  UserUser
  { userUserCreated = Nothing
  , userUserEmail = Nothing
  , userUserId = Nothing
  , userUserName = Nothing
  , userUserUpdated = Nothing
  , userUserUsername = Nothing
  }

-- ** V1AuthInfo
-- | V1AuthInfo
data V1AuthInfo = V1AuthInfo
  { v1AuthInfoLocal :: !(Maybe V1LocalAuthInfo) -- ^ "local"
  , v1AuthInfoOpenidConnect :: !(Maybe V1OpenIDAuthInfo) -- ^ "openid_connect"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1AuthInfo
instance A.FromJSON V1AuthInfo where
  parseJSON = A.withObject "V1AuthInfo" $ \o ->
    V1AuthInfo
      <$> (o .:? "local")
      <*> (o .:? "openid_connect")

-- | ToJSON V1AuthInfo
instance A.ToJSON V1AuthInfo where
  toJSON V1AuthInfo {..} =
   _omitNulls
      [ "local" .= v1AuthInfoLocal
      , "openid_connect" .= v1AuthInfoOpenidConnect
      ]


-- | Construct a value of type 'V1AuthInfo' (by applying it's required fields, if any)
mkV1AuthInfo
  :: V1AuthInfo
mkV1AuthInfo =
  V1AuthInfo
  { v1AuthInfoLocal = Nothing
  , v1AuthInfoOpenidConnect = Nothing
  }

-- ** V1LegalInfo
-- | V1LegalInfo
data V1LegalInfo = V1LegalInfo
  { v1LegalInfoImprintUrl :: !(Maybe Text) -- ^ "imprint_url"
  , v1LegalInfoPrivacyPolicyUrl :: !(Maybe Text) -- ^ "privacy_policy_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1LegalInfo
instance A.FromJSON V1LegalInfo where
  parseJSON = A.withObject "V1LegalInfo" $ \o ->
    V1LegalInfo
      <$> (o .:? "imprint_url")
      <*> (o .:? "privacy_policy_url")

-- | ToJSON V1LegalInfo
instance A.ToJSON V1LegalInfo where
  toJSON V1LegalInfo {..} =
   _omitNulls
      [ "imprint_url" .= v1LegalInfoImprintUrl
      , "privacy_policy_url" .= v1LegalInfoPrivacyPolicyUrl
      ]


-- | Construct a value of type 'V1LegalInfo' (by applying it's required fields, if any)
mkV1LegalInfo
  :: V1LegalInfo
mkV1LegalInfo =
  V1LegalInfo
  { v1LegalInfoImprintUrl = Nothing
  , v1LegalInfoPrivacyPolicyUrl = Nothing
  }

-- ** V1LinkShareAuth
-- | V1LinkShareAuth
data V1LinkShareAuth = V1LinkShareAuth
  { v1LinkShareAuthPassword :: !(Maybe Text) -- ^ "password"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1LinkShareAuth
instance A.FromJSON V1LinkShareAuth where
  parseJSON = A.withObject "V1LinkShareAuth" $ \o ->
    V1LinkShareAuth
      <$> (o .:? "password")

-- | ToJSON V1LinkShareAuth
instance A.ToJSON V1LinkShareAuth where
  toJSON V1LinkShareAuth {..} =
   _omitNulls
      [ "password" .= v1LinkShareAuthPassword
      ]


-- | Construct a value of type 'V1LinkShareAuth' (by applying it's required fields, if any)
mkV1LinkShareAuth
  :: V1LinkShareAuth
mkV1LinkShareAuth =
  V1LinkShareAuth
  { v1LinkShareAuthPassword = Nothing
  }

-- ** V1LocalAuthInfo
-- | V1LocalAuthInfo
data V1LocalAuthInfo = V1LocalAuthInfo
  { v1LocalAuthInfoEnabled :: !(Maybe Bool) -- ^ "enabled"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1LocalAuthInfo
instance A.FromJSON V1LocalAuthInfo where
  parseJSON = A.withObject "V1LocalAuthInfo" $ \o ->
    V1LocalAuthInfo
      <$> (o .:? "enabled")

-- | ToJSON V1LocalAuthInfo
instance A.ToJSON V1LocalAuthInfo where
  toJSON V1LocalAuthInfo {..} =
   _omitNulls
      [ "enabled" .= v1LocalAuthInfoEnabled
      ]


-- | Construct a value of type 'V1LocalAuthInfo' (by applying it's required fields, if any)
mkV1LocalAuthInfo
  :: V1LocalAuthInfo
mkV1LocalAuthInfo =
  V1LocalAuthInfo
  { v1LocalAuthInfoEnabled = Nothing
  }

-- ** V1OpenIDAuthInfo
-- | V1OpenIDAuthInfo
data V1OpenIDAuthInfo = V1OpenIDAuthInfo
  { v1OpenIDAuthInfoEnabled :: !(Maybe Bool) -- ^ "enabled"
  , v1OpenIDAuthInfoProviders :: !(Maybe [OpenidProvider]) -- ^ "providers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1OpenIDAuthInfo
instance A.FromJSON V1OpenIDAuthInfo where
  parseJSON = A.withObject "V1OpenIDAuthInfo" $ \o ->
    V1OpenIDAuthInfo
      <$> (o .:? "enabled")
      <*> (o .:? "providers")

-- | ToJSON V1OpenIDAuthInfo
instance A.ToJSON V1OpenIDAuthInfo where
  toJSON V1OpenIDAuthInfo {..} =
   _omitNulls
      [ "enabled" .= v1OpenIDAuthInfoEnabled
      , "providers" .= v1OpenIDAuthInfoProviders
      ]


-- | Construct a value of type 'V1OpenIDAuthInfo' (by applying it's required fields, if any)
mkV1OpenIDAuthInfo
  :: V1OpenIDAuthInfo
mkV1OpenIDAuthInfo =
  V1OpenIDAuthInfo
  { v1OpenIDAuthInfoEnabled = Nothing
  , v1OpenIDAuthInfoProviders = Nothing
  }

-- ** V1UserAvatarProvider
-- | V1UserAvatarProvider
data V1UserAvatarProvider = V1UserAvatarProvider
  { v1UserAvatarProviderAvatarProvider :: !(Maybe Text) -- ^ "avatar_provider" - The avatar provider. Valid types are &#x60;gravatar&#x60; (uses the user email), &#x60;upload&#x60;, &#x60;initials&#x60;, &#x60;marble&#x60; (generates a random avatar for each user), &#x60;default&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1UserAvatarProvider
instance A.FromJSON V1UserAvatarProvider where
  parseJSON = A.withObject "V1UserAvatarProvider" $ \o ->
    V1UserAvatarProvider
      <$> (o .:? "avatar_provider")

-- | ToJSON V1UserAvatarProvider
instance A.ToJSON V1UserAvatarProvider where
  toJSON V1UserAvatarProvider {..} =
   _omitNulls
      [ "avatar_provider" .= v1UserAvatarProviderAvatarProvider
      ]


-- | Construct a value of type 'V1UserAvatarProvider' (by applying it's required fields, if any)
mkV1UserAvatarProvider
  :: V1UserAvatarProvider
mkV1UserAvatarProvider =
  V1UserAvatarProvider
  { v1UserAvatarProviderAvatarProvider = Nothing
  }

-- ** V1UserDeletionRequestConfirm
-- | V1UserDeletionRequestConfirm
data V1UserDeletionRequestConfirm = V1UserDeletionRequestConfirm
  { v1UserDeletionRequestConfirmToken :: !(Maybe Text) -- ^ "token"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1UserDeletionRequestConfirm
instance A.FromJSON V1UserDeletionRequestConfirm where
  parseJSON = A.withObject "V1UserDeletionRequestConfirm" $ \o ->
    V1UserDeletionRequestConfirm
      <$> (o .:? "token")

-- | ToJSON V1UserDeletionRequestConfirm
instance A.ToJSON V1UserDeletionRequestConfirm where
  toJSON V1UserDeletionRequestConfirm {..} =
   _omitNulls
      [ "token" .= v1UserDeletionRequestConfirmToken
      ]


-- | Construct a value of type 'V1UserDeletionRequestConfirm' (by applying it's required fields, if any)
mkV1UserDeletionRequestConfirm
  :: V1UserDeletionRequestConfirm
mkV1UserDeletionRequestConfirm =
  V1UserDeletionRequestConfirm
  { v1UserDeletionRequestConfirmToken = Nothing
  }

-- ** V1UserPassword
-- | V1UserPassword
data V1UserPassword = V1UserPassword
  { v1UserPasswordNewPassword :: !(Maybe Text) -- ^ "new_password"
  , v1UserPasswordOldPassword :: !(Maybe Text) -- ^ "old_password"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1UserPassword
instance A.FromJSON V1UserPassword where
  parseJSON = A.withObject "V1UserPassword" $ \o ->
    V1UserPassword
      <$> (o .:? "new_password")
      <*> (o .:? "old_password")

-- | ToJSON V1UserPassword
instance A.ToJSON V1UserPassword where
  toJSON V1UserPassword {..} =
   _omitNulls
      [ "new_password" .= v1UserPasswordNewPassword
      , "old_password" .= v1UserPasswordOldPassword
      ]


-- | Construct a value of type 'V1UserPassword' (by applying it's required fields, if any)
mkV1UserPassword
  :: V1UserPassword
mkV1UserPassword =
  V1UserPassword
  { v1UserPasswordNewPassword = Nothing
  , v1UserPasswordOldPassword = Nothing
  }

-- ** V1UserPasswordConfirmation
-- | V1UserPasswordConfirmation
data V1UserPasswordConfirmation = V1UserPasswordConfirmation
  { v1UserPasswordConfirmationPassword :: !(Maybe Text) -- ^ "password"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1UserPasswordConfirmation
instance A.FromJSON V1UserPasswordConfirmation where
  parseJSON = A.withObject "V1UserPasswordConfirmation" $ \o ->
    V1UserPasswordConfirmation
      <$> (o .:? "password")

-- | ToJSON V1UserPasswordConfirmation
instance A.ToJSON V1UserPasswordConfirmation where
  toJSON V1UserPasswordConfirmation {..} =
   _omitNulls
      [ "password" .= v1UserPasswordConfirmationPassword
      ]


-- | Construct a value of type 'V1UserPasswordConfirmation' (by applying it's required fields, if any)
mkV1UserPasswordConfirmation
  :: V1UserPasswordConfirmation
mkV1UserPasswordConfirmation =
  V1UserPasswordConfirmation
  { v1UserPasswordConfirmationPassword = Nothing
  }

-- ** V1UserSettings
-- | V1UserSettings
data V1UserSettings = V1UserSettings
  { v1UserSettingsDefaultProjectId :: !(Maybe Int) -- ^ "default_project_id" - If a task is created without a specified project this value should be used. Applies to tasks made directly in API and from clients.
  , v1UserSettingsDiscoverableByEmail :: !(Maybe Bool) -- ^ "discoverable_by_email" - If true, the user can be found when searching for their exact email.
  , v1UserSettingsDiscoverableByName :: !(Maybe Bool) -- ^ "discoverable_by_name" - If true, this user can be found by their name or parts of it when searching for it.
  , v1UserSettingsEmailRemindersEnabled :: !(Maybe Bool) -- ^ "email_reminders_enabled" - If enabled, sends email reminders of tasks to the user.
  , v1UserSettingsFrontendSettings :: !(Maybe A.Value) -- ^ "frontend_settings" - Additional settings only used by the frontend
  , v1UserSettingsLanguage :: !(Maybe Text) -- ^ "language" - The user&#39;s language
  , v1UserSettingsName :: !(Maybe Text) -- ^ "name" - The new name of the current user.
  , v1UserSettingsOverdueTasksRemindersEnabled :: !(Maybe Bool) -- ^ "overdue_tasks_reminders_enabled" - If enabled, the user will get an email for their overdue tasks each morning.
  , v1UserSettingsOverdueTasksRemindersTime :: !(Maybe Text) -- ^ "overdue_tasks_reminders_time" - The time when the daily summary of overdue tasks will be sent via email.
  , v1UserSettingsTimezone :: !(Maybe Text) -- ^ "timezone" - The user&#39;s time zone. Used to send task reminders in the time zone of the user.
  , v1UserSettingsWeekStart :: !(Maybe Int) -- ^ "week_start" - The day when the week starts for this user. 0 &#x3D; sunday, 1 &#x3D; monday, etc.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1UserSettings
instance A.FromJSON V1UserSettings where
  parseJSON = A.withObject "V1UserSettings" $ \o ->
    V1UserSettings
      <$> (o .:? "default_project_id")
      <*> (o .:? "discoverable_by_email")
      <*> (o .:? "discoverable_by_name")
      <*> (o .:? "email_reminders_enabled")
      <*> (o .:? "frontend_settings")
      <*> (o .:? "language")
      <*> (o .:? "name")
      <*> (o .:? "overdue_tasks_reminders_enabled")
      <*> (o .:? "overdue_tasks_reminders_time")
      <*> (o .:? "timezone")
      <*> (o .:? "week_start")

-- | ToJSON V1UserSettings
instance A.ToJSON V1UserSettings where
  toJSON V1UserSettings {..} =
   _omitNulls
      [ "default_project_id" .= v1UserSettingsDefaultProjectId
      , "discoverable_by_email" .= v1UserSettingsDiscoverableByEmail
      , "discoverable_by_name" .= v1UserSettingsDiscoverableByName
      , "email_reminders_enabled" .= v1UserSettingsEmailRemindersEnabled
      , "frontend_settings" .= v1UserSettingsFrontendSettings
      , "language" .= v1UserSettingsLanguage
      , "name" .= v1UserSettingsName
      , "overdue_tasks_reminders_enabled" .= v1UserSettingsOverdueTasksRemindersEnabled
      , "overdue_tasks_reminders_time" .= v1UserSettingsOverdueTasksRemindersTime
      , "timezone" .= v1UserSettingsTimezone
      , "week_start" .= v1UserSettingsWeekStart
      ]


-- | Construct a value of type 'V1UserSettings' (by applying it's required fields, if any)
mkV1UserSettings
  :: V1UserSettings
mkV1UserSettings =
  V1UserSettings
  { v1UserSettingsDefaultProjectId = Nothing
  , v1UserSettingsDiscoverableByEmail = Nothing
  , v1UserSettingsDiscoverableByName = Nothing
  , v1UserSettingsEmailRemindersEnabled = Nothing
  , v1UserSettingsFrontendSettings = Nothing
  , v1UserSettingsLanguage = Nothing
  , v1UserSettingsName = Nothing
  , v1UserSettingsOverdueTasksRemindersEnabled = Nothing
  , v1UserSettingsOverdueTasksRemindersTime = Nothing
  , v1UserSettingsTimezone = Nothing
  , v1UserSettingsWeekStart = Nothing
  }

-- ** V1UserWithSettings
-- | V1UserWithSettings
data V1UserWithSettings = V1UserWithSettings
  { v1UserWithSettingsCreated :: !(Maybe Text) -- ^ "created" - A timestamp when this task was created. You cannot change this value.
  , v1UserWithSettingsDeletionScheduledAt :: !(Maybe Text) -- ^ "deletion_scheduled_at"
  , v1UserWithSettingsEmail :: !(Maybe Text) -- ^ "email" - The user&#39;s email address.
  , v1UserWithSettingsId :: !(Maybe Int) -- ^ "id" - The unique, numeric id of this user.
  , v1UserWithSettingsIsLocalUser :: !(Maybe Bool) -- ^ "is_local_user"
  , v1UserWithSettingsName :: !(Maybe Text) -- ^ "name" - The full name of the user.
  , v1UserWithSettingsSettings :: !(Maybe V1UserSettings) -- ^ "settings"
  , v1UserWithSettingsUpdated :: !(Maybe Text) -- ^ "updated" - A timestamp when this task was last updated. You cannot change this value.
  , v1UserWithSettingsUsername :: !(Maybe Text) -- ^ "username" - The username of the user. Is always unique.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1UserWithSettings
instance A.FromJSON V1UserWithSettings where
  parseJSON = A.withObject "V1UserWithSettings" $ \o ->
    V1UserWithSettings
      <$> (o .:? "created")
      <*> (o .:? "deletion_scheduled_at")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "is_local_user")
      <*> (o .:? "name")
      <*> (o .:? "settings")
      <*> (o .:? "updated")
      <*> (o .:? "username")

-- | ToJSON V1UserWithSettings
instance A.ToJSON V1UserWithSettings where
  toJSON V1UserWithSettings {..} =
   _omitNulls
      [ "created" .= v1UserWithSettingsCreated
      , "deletion_scheduled_at" .= v1UserWithSettingsDeletionScheduledAt
      , "email" .= v1UserWithSettingsEmail
      , "id" .= v1UserWithSettingsId
      , "is_local_user" .= v1UserWithSettingsIsLocalUser
      , "name" .= v1UserWithSettingsName
      , "settings" .= v1UserWithSettingsSettings
      , "updated" .= v1UserWithSettingsUpdated
      , "username" .= v1UserWithSettingsUsername
      ]


-- | Construct a value of type 'V1UserWithSettings' (by applying it's required fields, if any)
mkV1UserWithSettings
  :: V1UserWithSettings
mkV1UserWithSettings =
  V1UserWithSettings
  { v1UserWithSettingsCreated = Nothing
  , v1UserWithSettingsDeletionScheduledAt = Nothing
  , v1UserWithSettingsEmail = Nothing
  , v1UserWithSettingsId = Nothing
  , v1UserWithSettingsIsLocalUser = Nothing
  , v1UserWithSettingsName = Nothing
  , v1UserWithSettingsSettings = Nothing
  , v1UserWithSettingsUpdated = Nothing
  , v1UserWithSettingsUsername = Nothing
  }

-- ** V1VikunjaInfos
-- | V1VikunjaInfos
data V1VikunjaInfos = V1VikunjaInfos
  { v1VikunjaInfosAuth :: !(Maybe V1AuthInfo) -- ^ "auth"
  , v1VikunjaInfosAvailableMigrators :: !(Maybe [Text]) -- ^ "available_migrators"
  , v1VikunjaInfosCaldavEnabled :: !(Maybe Bool) -- ^ "caldav_enabled"
  , v1VikunjaInfosDemoModeEnabled :: !(Maybe Bool) -- ^ "demo_mode_enabled"
  , v1VikunjaInfosEmailRemindersEnabled :: !(Maybe Bool) -- ^ "email_reminders_enabled"
  , v1VikunjaInfosEnabledBackgroundProviders :: !(Maybe [Text]) -- ^ "enabled_background_providers"
  , v1VikunjaInfosFrontendUrl :: !(Maybe Text) -- ^ "frontend_url"
  , v1VikunjaInfosLegal :: !(Maybe V1LegalInfo) -- ^ "legal"
  , v1VikunjaInfosLinkSharingEnabled :: !(Maybe Bool) -- ^ "link_sharing_enabled"
  , v1VikunjaInfosMaxFileSize :: !(Maybe Text) -- ^ "max_file_size"
  , v1VikunjaInfosMotd :: !(Maybe Text) -- ^ "motd"
  , v1VikunjaInfosPublicTeamsEnabled :: !(Maybe Bool) -- ^ "public_teams_enabled"
  , v1VikunjaInfosRegistrationEnabled :: !(Maybe Bool) -- ^ "registration_enabled"
  , v1VikunjaInfosTaskAttachmentsEnabled :: !(Maybe Bool) -- ^ "task_attachments_enabled"
  , v1VikunjaInfosTaskCommentsEnabled :: !(Maybe Bool) -- ^ "task_comments_enabled"
  , v1VikunjaInfosTotpEnabled :: !(Maybe Bool) -- ^ "totp_enabled"
  , v1VikunjaInfosUserDeletionEnabled :: !(Maybe Bool) -- ^ "user_deletion_enabled"
  , v1VikunjaInfosVersion :: !(Maybe Text) -- ^ "version"
  , v1VikunjaInfosWebhooksEnabled :: !(Maybe Bool) -- ^ "webhooks_enabled"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1VikunjaInfos
instance A.FromJSON V1VikunjaInfos where
  parseJSON = A.withObject "V1VikunjaInfos" $ \o ->
    V1VikunjaInfos
      <$> (o .:? "auth")
      <*> (o .:? "available_migrators")
      <*> (o .:? "caldav_enabled")
      <*> (o .:? "demo_mode_enabled")
      <*> (o .:? "email_reminders_enabled")
      <*> (o .:? "enabled_background_providers")
      <*> (o .:? "frontend_url")
      <*> (o .:? "legal")
      <*> (o .:? "link_sharing_enabled")
      <*> (o .:? "max_file_size")
      <*> (o .:? "motd")
      <*> (o .:? "public_teams_enabled")
      <*> (o .:? "registration_enabled")
      <*> (o .:? "task_attachments_enabled")
      <*> (o .:? "task_comments_enabled")
      <*> (o .:? "totp_enabled")
      <*> (o .:? "user_deletion_enabled")
      <*> (o .:? "version")
      <*> (o .:? "webhooks_enabled")

-- | ToJSON V1VikunjaInfos
instance A.ToJSON V1VikunjaInfos where
  toJSON V1VikunjaInfos {..} =
   _omitNulls
      [ "auth" .= v1VikunjaInfosAuth
      , "available_migrators" .= v1VikunjaInfosAvailableMigrators
      , "caldav_enabled" .= v1VikunjaInfosCaldavEnabled
      , "demo_mode_enabled" .= v1VikunjaInfosDemoModeEnabled
      , "email_reminders_enabled" .= v1VikunjaInfosEmailRemindersEnabled
      , "enabled_background_providers" .= v1VikunjaInfosEnabledBackgroundProviders
      , "frontend_url" .= v1VikunjaInfosFrontendUrl
      , "legal" .= v1VikunjaInfosLegal
      , "link_sharing_enabled" .= v1VikunjaInfosLinkSharingEnabled
      , "max_file_size" .= v1VikunjaInfosMaxFileSize
      , "motd" .= v1VikunjaInfosMotd
      , "public_teams_enabled" .= v1VikunjaInfosPublicTeamsEnabled
      , "registration_enabled" .= v1VikunjaInfosRegistrationEnabled
      , "task_attachments_enabled" .= v1VikunjaInfosTaskAttachmentsEnabled
      , "task_comments_enabled" .= v1VikunjaInfosTaskCommentsEnabled
      , "totp_enabled" .= v1VikunjaInfosTotpEnabled
      , "user_deletion_enabled" .= v1VikunjaInfosUserDeletionEnabled
      , "version" .= v1VikunjaInfosVersion
      , "webhooks_enabled" .= v1VikunjaInfosWebhooksEnabled
      ]


-- | Construct a value of type 'V1VikunjaInfos' (by applying it's required fields, if any)
mkV1VikunjaInfos
  :: V1VikunjaInfos
mkV1VikunjaInfos =
  V1VikunjaInfos
  { v1VikunjaInfosAuth = Nothing
  , v1VikunjaInfosAvailableMigrators = Nothing
  , v1VikunjaInfosCaldavEnabled = Nothing
  , v1VikunjaInfosDemoModeEnabled = Nothing
  , v1VikunjaInfosEmailRemindersEnabled = Nothing
  , v1VikunjaInfosEnabledBackgroundProviders = Nothing
  , v1VikunjaInfosFrontendUrl = Nothing
  , v1VikunjaInfosLegal = Nothing
  , v1VikunjaInfosLinkSharingEnabled = Nothing
  , v1VikunjaInfosMaxFileSize = Nothing
  , v1VikunjaInfosMotd = Nothing
  , v1VikunjaInfosPublicTeamsEnabled = Nothing
  , v1VikunjaInfosRegistrationEnabled = Nothing
  , v1VikunjaInfosTaskAttachmentsEnabled = Nothing
  , v1VikunjaInfosTaskCommentsEnabled = Nothing
  , v1VikunjaInfosTotpEnabled = Nothing
  , v1VikunjaInfosUserDeletionEnabled = Nothing
  , v1VikunjaInfosVersion = Nothing
  , v1VikunjaInfosWebhooksEnabled = Nothing
  }

-- ** WebHTTPError
-- | WebHTTPError
data WebHTTPError = WebHTTPError
  { webHTTPErrorCode :: !(Maybe Int) -- ^ "code"
  , webHTTPErrorMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebHTTPError
instance A.FromJSON WebHTTPError where
  parseJSON = A.withObject "WebHTTPError" $ \o ->
    WebHTTPError
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON WebHTTPError
instance A.ToJSON WebHTTPError where
  toJSON WebHTTPError {..} =
   _omitNulls
      [ "code" .= webHTTPErrorCode
      , "message" .= webHTTPErrorMessage
      ]


-- | Construct a value of type 'WebHTTPError' (by applying it's required fields, if any)
mkWebHTTPError
  :: WebHTTPError
mkWebHTTPError =
  WebHTTPError
  { webHTTPErrorCode = Nothing
  , webHTTPErrorMessage = Nothing
  }


-- * Enums


-- ** ModelsBucketConfigurationModeKind

-- | Enum of 'Int'
data ModelsBucketConfigurationModeKind
  = ModelsBucketConfigurationModeKindBucketConfigurationModeNone -- ^ @0@
  | ModelsBucketConfigurationModeKindBucketConfigurationModeManual -- ^ @1@
  | ModelsBucketConfigurationModeKindBucketConfigurationModeFilter -- ^ @2@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelsBucketConfigurationModeKind where toJSON = A.toJSON . fromModelsBucketConfigurationModeKind
instance A.FromJSON ModelsBucketConfigurationModeKind where parseJSON o = P.either P.fail (pure . P.id) . toModelsBucketConfigurationModeKind =<< A.parseJSON o
instance WH.ToHttpApiData ModelsBucketConfigurationModeKind where toQueryParam = WH.toQueryParam . fromModelsBucketConfigurationModeKind
instance WH.FromHttpApiData ModelsBucketConfigurationModeKind where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelsBucketConfigurationModeKind
instance MimeRender MimeMultipartFormData ModelsBucketConfigurationModeKind where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelsBucketConfigurationModeKind' enum
fromModelsBucketConfigurationModeKind :: ModelsBucketConfigurationModeKind -> Int
fromModelsBucketConfigurationModeKind = \case
  ModelsBucketConfigurationModeKindBucketConfigurationModeNone -> 0
  ModelsBucketConfigurationModeKindBucketConfigurationModeManual -> 1
  ModelsBucketConfigurationModeKindBucketConfigurationModeFilter -> 2

-- | parse 'ModelsBucketConfigurationModeKind' enum
toModelsBucketConfigurationModeKind :: Int -> P.Either String ModelsBucketConfigurationModeKind
toModelsBucketConfigurationModeKind = \case
  0 -> P.Right ModelsBucketConfigurationModeKindBucketConfigurationModeNone
  1 -> P.Right ModelsBucketConfigurationModeKindBucketConfigurationModeManual
  2 -> P.Right ModelsBucketConfigurationModeKindBucketConfigurationModeFilter
  s -> P.Left $ "toModelsBucketConfigurationModeKind: enum parse failure: " P.++ P.show s


-- ** ModelsProjectViewKind

-- | Enum of 'Int'
data ModelsProjectViewKind
  = ModelsProjectViewKindProjectViewKindList -- ^ @0@
  | ModelsProjectViewKindProjectViewKindGantt -- ^ @1@
  | ModelsProjectViewKindProjectViewKindTable -- ^ @2@
  | ModelsProjectViewKindProjectViewKindKanban -- ^ @3@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelsProjectViewKind where toJSON = A.toJSON . fromModelsProjectViewKind
instance A.FromJSON ModelsProjectViewKind where parseJSON o = P.either P.fail (pure . P.id) . toModelsProjectViewKind =<< A.parseJSON o
instance WH.ToHttpApiData ModelsProjectViewKind where toQueryParam = WH.toQueryParam . fromModelsProjectViewKind
instance WH.FromHttpApiData ModelsProjectViewKind where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelsProjectViewKind
instance MimeRender MimeMultipartFormData ModelsProjectViewKind where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelsProjectViewKind' enum
fromModelsProjectViewKind :: ModelsProjectViewKind -> Int
fromModelsProjectViewKind = \case
  ModelsProjectViewKindProjectViewKindList -> 0
  ModelsProjectViewKindProjectViewKindGantt -> 1
  ModelsProjectViewKindProjectViewKindTable -> 2
  ModelsProjectViewKindProjectViewKindKanban -> 3

-- | parse 'ModelsProjectViewKind' enum
toModelsProjectViewKind :: Int -> P.Either String ModelsProjectViewKind
toModelsProjectViewKind = \case
  0 -> P.Right ModelsProjectViewKindProjectViewKindList
  1 -> P.Right ModelsProjectViewKindProjectViewKindGantt
  2 -> P.Right ModelsProjectViewKindProjectViewKindTable
  3 -> P.Right ModelsProjectViewKindProjectViewKindKanban
  s -> P.Left $ "toModelsProjectViewKind: enum parse failure: " P.++ P.show s


-- ** ModelsRelationKind

-- | Enum of 'Text'
data ModelsRelationKind
  = ModelsRelationKindRelationKindUnknown -- ^ @"unknown"@
  | ModelsRelationKindRelationKindSubtask -- ^ @"subtask"@
  | ModelsRelationKindRelationKindParenttask -- ^ @"parenttask"@
  | ModelsRelationKindRelationKindRelated -- ^ @"related"@
  | ModelsRelationKindRelationKindDuplicateOf -- ^ @"duplicateof"@
  | ModelsRelationKindRelationKindDuplicates -- ^ @"duplicates"@
  | ModelsRelationKindRelationKindBlocking -- ^ @"blocking"@
  | ModelsRelationKindRelationKindBlocked -- ^ @"blocked"@
  | ModelsRelationKindRelationKindPreceeds -- ^ @"precedes"@
  | ModelsRelationKindRelationKindFollows -- ^ @"follows"@
  | ModelsRelationKindRelationKindCopiedFrom -- ^ @"copiedfrom"@
  | ModelsRelationKindRelationKindCopiedTo -- ^ @"copiedto"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelsRelationKind where toJSON = A.toJSON . fromModelsRelationKind
instance A.FromJSON ModelsRelationKind where parseJSON o = P.either P.fail (pure . P.id) . toModelsRelationKind =<< A.parseJSON o
instance WH.ToHttpApiData ModelsRelationKind where toQueryParam = WH.toQueryParam . fromModelsRelationKind
instance WH.FromHttpApiData ModelsRelationKind where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelsRelationKind
instance MimeRender MimeMultipartFormData ModelsRelationKind where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelsRelationKind' enum
fromModelsRelationKind :: ModelsRelationKind -> Text
fromModelsRelationKind = \case
  ModelsRelationKindRelationKindUnknown -> "unknown"
  ModelsRelationKindRelationKindSubtask -> "subtask"
  ModelsRelationKindRelationKindParenttask -> "parenttask"
  ModelsRelationKindRelationKindRelated -> "related"
  ModelsRelationKindRelationKindDuplicateOf -> "duplicateof"
  ModelsRelationKindRelationKindDuplicates -> "duplicates"
  ModelsRelationKindRelationKindBlocking -> "blocking"
  ModelsRelationKindRelationKindBlocked -> "blocked"
  ModelsRelationKindRelationKindPreceeds -> "precedes"
  ModelsRelationKindRelationKindFollows -> "follows"
  ModelsRelationKindRelationKindCopiedFrom -> "copiedfrom"
  ModelsRelationKindRelationKindCopiedTo -> "copiedto"

-- | parse 'ModelsRelationKind' enum
toModelsRelationKind :: Text -> P.Either String ModelsRelationKind
toModelsRelationKind = \case
  "unknown" -> P.Right ModelsRelationKindRelationKindUnknown
  "subtask" -> P.Right ModelsRelationKindRelationKindSubtask
  "parenttask" -> P.Right ModelsRelationKindRelationKindParenttask
  "related" -> P.Right ModelsRelationKindRelationKindRelated
  "duplicateof" -> P.Right ModelsRelationKindRelationKindDuplicateOf
  "duplicates" -> P.Right ModelsRelationKindRelationKindDuplicates
  "blocking" -> P.Right ModelsRelationKindRelationKindBlocking
  "blocked" -> P.Right ModelsRelationKindRelationKindBlocked
  "precedes" -> P.Right ModelsRelationKindRelationKindPreceeds
  "follows" -> P.Right ModelsRelationKindRelationKindFollows
  "copiedfrom" -> P.Right ModelsRelationKindRelationKindCopiedFrom
  "copiedto" -> P.Right ModelsRelationKindRelationKindCopiedTo
  s -> P.Left $ "toModelsRelationKind: enum parse failure: " P.++ P.show s


-- ** ModelsReminderRelation

-- | Enum of 'Text'
data ModelsReminderRelation
  = ModelsReminderRelationReminderRelationDueDate -- ^ @"due_date"@
  | ModelsReminderRelationReminderRelationStartDate -- ^ @"start_date"@
  | ModelsReminderRelationReminderRelationEndDate -- ^ @"end_date"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelsReminderRelation where toJSON = A.toJSON . fromModelsReminderRelation
instance A.FromJSON ModelsReminderRelation where parseJSON o = P.either P.fail (pure . P.id) . toModelsReminderRelation =<< A.parseJSON o
instance WH.ToHttpApiData ModelsReminderRelation where toQueryParam = WH.toQueryParam . fromModelsReminderRelation
instance WH.FromHttpApiData ModelsReminderRelation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelsReminderRelation
instance MimeRender MimeMultipartFormData ModelsReminderRelation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelsReminderRelation' enum
fromModelsReminderRelation :: ModelsReminderRelation -> Text
fromModelsReminderRelation = \case
  ModelsReminderRelationReminderRelationDueDate -> "due_date"
  ModelsReminderRelationReminderRelationStartDate -> "start_date"
  ModelsReminderRelationReminderRelationEndDate -> "end_date"

-- | parse 'ModelsReminderRelation' enum
toModelsReminderRelation :: Text -> P.Either String ModelsReminderRelation
toModelsReminderRelation = \case
  "due_date" -> P.Right ModelsReminderRelationReminderRelationDueDate
  "start_date" -> P.Right ModelsReminderRelationReminderRelationStartDate
  "end_date" -> P.Right ModelsReminderRelationReminderRelationEndDate
  s -> P.Left $ "toModelsReminderRelation: enum parse failure: " P.++ P.show s


-- ** ModelsRight

-- | Enum of 'Int'
data ModelsRight
  = ModelsRightRightRead -- ^ @0@
  | ModelsRightRightWrite -- ^ @1@
  | ModelsRightRightAdmin -- ^ @2@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelsRight where toJSON = A.toJSON . fromModelsRight
instance A.FromJSON ModelsRight where parseJSON o = P.either P.fail (pure . P.id) . toModelsRight =<< A.parseJSON o
instance WH.ToHttpApiData ModelsRight where toQueryParam = WH.toQueryParam . fromModelsRight
instance WH.FromHttpApiData ModelsRight where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelsRight
instance MimeRender MimeMultipartFormData ModelsRight where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelsRight' enum
fromModelsRight :: ModelsRight -> Int
fromModelsRight = \case
  ModelsRightRightRead -> 0
  ModelsRightRightWrite -> 1
  ModelsRightRightAdmin -> 2

-- | parse 'ModelsRight' enum
toModelsRight :: Int -> P.Either String ModelsRight
toModelsRight = \case
  0 -> P.Right ModelsRightRightRead
  1 -> P.Right ModelsRightRightWrite
  2 -> P.Right ModelsRightRightAdmin
  s -> P.Left $ "toModelsRight: enum parse failure: " P.++ P.show s


-- ** ModelsSharingType

-- | Enum of 'Int'
data ModelsSharingType
  = ModelsSharingTypeSharingTypeUnknown -- ^ @0@
  | ModelsSharingTypeSharingTypeWithoutPassword -- ^ @1@
  | ModelsSharingTypeSharingTypeWithPassword -- ^ @2@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelsSharingType where toJSON = A.toJSON . fromModelsSharingType
instance A.FromJSON ModelsSharingType where parseJSON o = P.either P.fail (pure . P.id) . toModelsSharingType =<< A.parseJSON o
instance WH.ToHttpApiData ModelsSharingType where toQueryParam = WH.toQueryParam . fromModelsSharingType
instance WH.FromHttpApiData ModelsSharingType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelsSharingType
instance MimeRender MimeMultipartFormData ModelsSharingType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelsSharingType' enum
fromModelsSharingType :: ModelsSharingType -> Int
fromModelsSharingType = \case
  ModelsSharingTypeSharingTypeUnknown -> 0
  ModelsSharingTypeSharingTypeWithoutPassword -> 1
  ModelsSharingTypeSharingTypeWithPassword -> 2

-- | parse 'ModelsSharingType' enum
toModelsSharingType :: Int -> P.Either String ModelsSharingType
toModelsSharingType = \case
  0 -> P.Right ModelsSharingTypeSharingTypeUnknown
  1 -> P.Right ModelsSharingTypeSharingTypeWithoutPassword
  2 -> P.Right ModelsSharingTypeSharingTypeWithPassword
  s -> P.Left $ "toModelsSharingType: enum parse failure: " P.++ P.show s


-- ** ModelsTaskRepeatMode

-- | Enum of 'Int'
data ModelsTaskRepeatMode
  = ModelsTaskRepeatModeTaskRepeatModeDefault -- ^ @0@
  | ModelsTaskRepeatModeTaskRepeatModeMonth -- ^ @1@
  | ModelsTaskRepeatModeTaskRepeatModeFromCurrentDate -- ^ @2@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ModelsTaskRepeatMode where toJSON = A.toJSON . fromModelsTaskRepeatMode
instance A.FromJSON ModelsTaskRepeatMode where parseJSON o = P.either P.fail (pure . P.id) . toModelsTaskRepeatMode =<< A.parseJSON o
instance WH.ToHttpApiData ModelsTaskRepeatMode where toQueryParam = WH.toQueryParam . fromModelsTaskRepeatMode
instance WH.FromHttpApiData ModelsTaskRepeatMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toModelsTaskRepeatMode
instance MimeRender MimeMultipartFormData ModelsTaskRepeatMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ModelsTaskRepeatMode' enum
fromModelsTaskRepeatMode :: ModelsTaskRepeatMode -> Int
fromModelsTaskRepeatMode = \case
  ModelsTaskRepeatModeTaskRepeatModeDefault -> 0
  ModelsTaskRepeatModeTaskRepeatModeMonth -> 1
  ModelsTaskRepeatModeTaskRepeatModeFromCurrentDate -> 2

-- | parse 'ModelsTaskRepeatMode' enum
toModelsTaskRepeatMode :: Int -> P.Either String ModelsTaskRepeatMode
toModelsTaskRepeatMode = \case
  0 -> P.Right ModelsTaskRepeatModeTaskRepeatModeDefault
  1 -> P.Right ModelsTaskRepeatModeTaskRepeatModeMonth
  2 -> P.Right ModelsTaskRepeatModeTaskRepeatModeFromCurrentDate
  s -> P.Left $ "toModelsTaskRepeatMode: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthBasicBasicAuth
data AuthBasicBasicAuth =
  AuthBasicBasicAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])

-- ** AuthApiKeyJWTKeyAuth
data AuthApiKeyJWTKeyAuth =
  AuthApiKeyJWTKeyAuth Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyJWTKeyAuth where
  applyAuthMethod _ a@(AuthApiKeyJWTKeyAuth secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


